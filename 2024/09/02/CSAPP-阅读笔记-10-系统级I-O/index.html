

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="7qing">
  <meta name="keywords" content="">
  
    <meta name="description" content="在Unix 系统中，是通过使用由内核提供的系统级 Unix I&#x2F;O 函数来实现这些较高级别的 I&#x2F;0 函数的。大多数时候，高级别 IO 函数工作良好，没有必要直接使用 Unix I&#x2F;O。那么为什么还要麻烦地学习 Unix I&#x2F;O 呢?  了解 UnixIO 将帮助你理解其他的系统概念。I&#x2F;O是系统操作不可或缺的一部分，因此我们经常遇到 IO 和其他系统概念之间的循环依赖。例如，I&#x2F;O 在进程的创建">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP_阅读笔记_10_系统级I&#x2F;O">
<meta property="og:url" content="http://example.com/2024/09/02/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-10-%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/index.html">
<meta property="og:site_name" content="7qing">
<meta property="og:description" content="在Unix 系统中，是通过使用由内核提供的系统级 Unix I&#x2F;O 函数来实现这些较高级别的 I&#x2F;0 函数的。大多数时候，高级别 IO 函数工作良好，没有必要直接使用 Unix I&#x2F;O。那么为什么还要麻烦地学习 Unix I&#x2F;O 呢?  了解 UnixIO 将帮助你理解其他的系统概念。I&#x2F;O是系统操作不可或缺的一部分，因此我们经常遇到 IO 和其他系统概念之间的循环依赖。例如，I&#x2F;O 在进程的创建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/7qing.png">
<meta property="article:published_time" content="2024-09-01T18:53:21.000Z">
<meta property="article:modified_time" content="2024-09-01T23:35:42.678Z">
<meta property="article:author" content="7qing">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="阅读笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/7qing.png">
  
  
  
  <title>CSAPP_阅读笔记_10_系统级I/O - 7qing</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","app_key":"IdTuwk7eTRDfLgZzPUknFG0z","server_url":"https://j6zz0vra.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>7qing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/backward.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP_阅读笔记_10_系统级I/O"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-02 02:53" pubdate>
          2024年9月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          46 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSAPP_阅读笔记_10_系统级I/O</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-09-02T07:35:42+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>在Unix 系统中，是通过使用由内核提供的系统级 Unix I/O 函数来实现这些较高级别的 I/0 函数的。大多数时候，高级别 IO 函数工作良好，没有必要直接使用 Unix I/O。那么为什么还要麻烦地学习 Unix I/O 呢?</p>
<ul>
<li>了解 UnixIO 将帮助你理解其他的系统概念。I/O是系统操作不可或缺的一部分，因此我们经常遇到 IO 和其他系统概念之间的循环依赖。例如，I/O 在进程的创建和执行中扮演着关键的角色。反过来，进程创建又在不同进程间的文件共享中扮演着关键角色。因此，要真正理解 I/O，你必须理解进程，反之亦然。在对存储器层次结构、链接和加载、进程以及虚拟存储器的讨论中，我们已经接触了I0的某些方面。既然你对这些概念有了比较好的理解，我们就能闭合这个循环，更加深入地研究 I/O。</li>
<li>有时你除了使用Unix I/O以外别无选择。在某些重要的情况下，使用高级 I/O 函数不太可能，或者不太合适。例如，标准 I/O库没有提供读取文件元数据的方式，如文件大小或文件创建时间。另外，I/O库还存在一些问题，使得用它来进行网络编程非常冒险。</li>
</ul>
<h1>1.Unix I/O</h1>
<p>​	一个Unix文件就是一个m个字节的序列:</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>B</mi><mi>k</mi></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>B</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_0,B_1,…,B_k,…,B_{m-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>​	所有的 IO 设备，如网络、磁盘和终端，都被模型化为<strong>文件</strong>，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Unix内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行:</p>
<ul>
<li>
<p>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 IO 设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</p>
<p>​	Unix 外壳创建的每个进程开始时都有三个打开的文件:</p>
<ul>
<li>标准输入(描述符为0)</li>
<li>标准输出(描述符为1)</li>
<li>标准错误(描述符为2)</li>
</ul>
<p>头文件&lt;unistd.h&gt;定义了常量</p>
<ul>
<li>STDIN_FILENO</li>
<li>STDOUT_FILENO</li>
<li>STDERR_FILENO</li>
</ul>
<p>它们可用来代替显式的描述符值。</p>
</li>
<li>
<p>改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个<br>
文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek 操作，显式地设置<br>
文件的当前位置为 k。</p>
</li>
<li>
<p>读写文件。一个读操作就是从文件拷贝n&gt;0个字节到存储器，从当前文件位置k开始<br>
然后将k增加到k+n。给定一个大小为m字节的文件，当k&gt;m时执行读操作会触发一<br>
个称为 end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”</p>
<p>​	类似地，写操作就是从存储器拷贝n&gt;0个字节到一个文件，从当前文件位置k开始然后更新 k。</p>
</li>
<li>
<p>关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的存储器资源。</p>
</li>
</ul>
<h2 id="文件">文件</h2>
<p>每个 Linux 文件都有一个表征其在系统中角色的类型：</p>
<ul>
<li>常规文件（Regular File）：对于应用程序来说，常规文件分为仅包含 ASCII 或 Unicode 字符的文本文件（Text File）和二进制文件（Binary File）；但对于内核而言，两者没有区别。Linux 文本文件由一系列文本行（Text Line）组成，其中每一行都以换行符<code>\n</code>结尾；</li>
<li>目录（Directory）：目录是由链接（Link）数组构成的文件。链接将一个文件名映射到一个文件，该文件可能是另一个目录（如下图所示）。每个目录中至少包含两个链接：<code>.</code>指向目录本身，而<code>..</code>指向上级目录；</li>
<li>Socket：用于通过网络与另一个进程通信的文件。</li>
</ul>
<p><img src="20220807220609.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1>2.打开和关闭文件</h1>
<p>​	进程是通过调用 open函数来打开一个已存在的文件或者创建一个新文件的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// Returns: new file descriptor if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>返回的文件描述符(fd)是进程当前未打开的最小描述符。参数<code>flags</code>指示进程如何访问文件：</p>
<ul>
<li><code>O_RDONLY</code>：只读</li>
<li><code>O_WRONLY</code>：只写</li>
<li><code>O_RDWR</code>：读写</li>
</ul>
<p>该参数还可以与一个或多个位掩码进行或（<code>OR</code>）运算，这些位掩码提供写入的附加说明：</p>
<ul>
<li><code>O_CREAT</code>：如果文件不存在，则创建一个空文件；</li>
<li><code>O_TRUNC</code>：如果文件已经存在，则清空文件内容；</li>
<li><code>O_APPEND</code>：在每次写入操作之前，将文件位置设置为文件末尾。</li>
</ul>
<p>若文件已存在，参数<code>mode</code>应设为 0；反之，则设为新文件的访问权限位，可选项如下图所示：</p>
<p><img src="6d1a7134c26b06592ac25b12c73d1a97.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	作为上下文的一部分，每个进程都有一个umask，它是通过调用umask函数来设置的。当进程通过带某个 mode 参数的 open函数调用来创建一个新文件时，文件的访问权限位被设置为 mode&amp; ~umask。例如，假设我们给定下面的mode和umask默认值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_UMASK  S_IWGRP|S_IWOTH</span><br><br>umask(DEF_UMASK);<br>fd = Open(<span class="hljs-string">&quot;foo.txt&quot;</span>, O_CREAT|O_TRUNC|O_WRONLY, DEF_MODE);<br></code></pre></td></tr></table></figure>
<p>​	最后，进程通过调用 <code>close</code>函数关闭一个打开的文件,若文件描述符已关闭将引发错误:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<h1>3.读和写文件</h1>
<p>​	应用程序分别调用<code>read</code>和<code>write</code>函数来执行输入和输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// Returns: number of bytes read if OK, 0 on EOF, −1 on error</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// Returns: number of bytes written if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>​	<code>read</code>函数从描述符为<code>fd</code>的当前文件位置复制最多<code>n</code>个字节到内存中<code>buf</code>指向的位置，<code>write</code>函数则从内存中<code>buf</code>指向的位置复制最多<code>n</code>个字节到参数<code>fd</code>的当前位置。示例程序使用上述两种函数将标准输入以字节为单位复制到标准输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span>(Read(STDIN_FILENO, &amp;c, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <br>        Write(STDOUT_FILENO, &amp;c, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-secondary">
            <p>​	<strong>ssizet和sizet有些什么区别?</strong><br>​	你可能已经注意到了，read函数有一个sizet的输入参数和一个ssizet的返回值。那么这两种类型之间有什么区别呢?size t被定义为unsigned int，而ssize t(有符号的大小)被定义为 int。read函数返回一个有符号的大小，而不是一个无符号的大小，这是因为出错时它必须返回一1。有趣的是，返回一个-1 的可能性使得 read 的最大值减小了一半,从 4GB 减小到了2GB。</p>
          </div>
<p>在某些情况下，读写操作传输的字节数小于应用程序请求的字节数。不足数（Short Count）的产生并不代表发生了错误，它可能由多种原因导致：</p>
<ul>
<li>读取时遇到 EOF：若我们对一个 20 字节的文件执行<code>read(fd, *buf, 50)</code>，那么第一次调用将返回一个 20 的不足数，第二次调用则返回 0（EOF）；</li>
<li>从终端读取文本行：若打开的文件是终端设备（即键盘和显示器），那么每次<code>read</code>调用都将传输一个文本行并返回一个与文本行大小相等的不足数；</li>
<li>读写 Socket：若打开的文件是 Socket，那么内部缓冲区限制和网络延迟将使读写操作返回不足数。</li>
</ul>
<p>因此除遇到 EOF 外，读写磁盘文件不会导致不足数的产生。但如果我们想要构建健壮而可靠的网络应用程序，就必须重复调用<code>read</code>和<code>write</code>以保证所有请求的字节均已被传输。</p>
<h1>4.用RIO包健壮地读写</h1>
<p>​	**RIO(Robust I0，健壮的I/O)**会自动为你处理上文中所述的不足值。在像网络程序这样容易出现不足值的应用中，RIO包提供了方便、健壮和高效的 IO。RIO 提供了两类不同的函数:</p>
<ul>
<li>无缓冲的输入输出函数。这些函数直接在存储器和文件之间传送数据，没有应用级缓冲<br>
它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。</li>
<li>带缓冲的输入函数。从应用程序级别的缓冲区中读取文本行和二进制数据，与标准 I/O（如<code>printf</code>）函数类似。该函数是**线程安全（Thread-safe）**的，并且可以对同一描述符任意交错（Interleave）。例如，我们可以从描述符中读取一些文本行，然后读取一些二进制数据，最后再读取一些文本行。</li>
</ul>
<h2 id="4-1-RIO的无缓冲的输入输出函数">4.1 RIO的无缓冲的输入输出函数</h2>
<p>​	通过调用<code>rio_readn</code>和 <code>rio_writen</code>函数，应用程序可以在存储器和文件之间直接传送数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// Returns: number of bytes transferred if OK, 0 on EOF (rio_readn only), −1 on error</span><br><br></code></pre></td></tr></table></figure>
<p><code>rio_readn</code>函数从参数<code>fd</code>的当前文件位置复制最多<code>n</code>个字节到内存中<code>usrbuf</code>指向的位置，<code>rio_writen</code>函数则从内存中<code>usrbuf</code>指向的位置复制最多<code>n</code>个字节到参数<code>fd</code>的当前位置。前者只有在遇到 EOF 时返回不足数，后者则从不返回不足数。</p>
<p>若上述函数被应用程序的信号处理程序的返回中断，它们会重新调用<code>read</code>和<code>write</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;<br>    <span class="hljs-type">ssize_t</span> nread;<br>    <span class="hljs-type">char</span> *bufp = usrbuf;<br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR) <span class="hljs-comment">/* Interrupted by sig handler return */</span><br>                nread = <span class="hljs-number">0</span>;      <span class="hljs-comment">/* and call read() again */</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">/* errno set by read() */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">/* EOF */</span><br>        nleft -= nread;<br>        bufp += nread;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (n - nleft);         <span class="hljs-comment">/* Return &gt;= 0 */</span><br>&#125;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;<br>    <span class="hljs-type">ssize_t</span> nwritten;<br>    <span class="hljs-type">char</span> *bufp = usrbuf;<br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((nwritten = read(fd, bufp, nleft)) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR) <span class="hljs-comment">/* Interrupted by sig handler return */</span><br>                nwritten = <span class="hljs-number">0</span>;   <span class="hljs-comment">/* and call write() again */</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">/* errno set by write() */</span><br>        &#125;<br>        nleft -= nwritten;<br>        bufp += nwritten;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-2-RIO的带缓冲的输入函数">4.2 RIO的带缓冲的输入函数</h2>
<p>​	假设我们需要编写一个计算文本文件行数的程序，最简单的方法便是调用<code>read</code>函数每次读取一个字节并检查是否有换行符。但由于<code>read</code>是系统调用，频繁的上下文切换将导致程序效率低下。</p>
<p>​	更好的方法是调用包装函数<code>rio_readlineb</code>从内部读取缓冲区（Read Buffer）复制文本行，只有当缓冲区为空时才调用<code>read</code>以重新填充缓冲区。RIO<em>R<strong>I</strong>O</em> 包还为同时包含文本行和二进制数据的文件（如 HTTP 响应）提供了<code>rio_readn</code>函数的有缓冲版本，即<code>rio_readnb</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> maxlen)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// Returns: number of bytes read if OK, 0 on EOF, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>​	在调用上述两种有缓冲的输入函数前，我们需要为每个打开文件描述符调用一次<code>rio_readinitb</code>。该函数将描述符<code>fd</code>与地址<code>rp</code>处的读取缓冲区（类型为<code>rio_t</code>）相关联：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RIO_BUFSIZE 8192</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> rio_fd;                <span class="hljs-comment">/* Descriptor for this internal buf */</span><br>    <span class="hljs-type">int</span> rio_cnt;               <span class="hljs-comment">/* Unread bytes in internal buf */</span><br>    <span class="hljs-type">char</span> *rio_bufptr;          <span class="hljs-comment">/* Next unread byte in internal buf */</span><br>    <span class="hljs-type">char</span> rio_buf[RIO_BUFSIZE]; <span class="hljs-comment">/* Internal buffer */</span><br>&#125; <span class="hljs-type">rio_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rio_readinitb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">int</span> fd)</span> <br>&#123;<br>    rp-&gt;rio_fd = fd;  <br>    rp-&gt;rio_cnt = <span class="hljs-number">0</span>;  <br>    rp-&gt;rio_bufptr = rp-&gt;rio_buf;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	RIO包读取例程的核心是<code>rio_read</code>函数，它其实是<code>read</code>函数的有缓冲版本。若读取缓冲区中的未读字节数<code>rp-&gt;rio_cnt</code>为 0，则在循环内调用<code>read</code>函数对其填充；若读取缓冲区非空，则调用<code>memcpy</code>函数将<code>min(n, rp-&gt;rio_cnt)</code>字节从缓冲区复制到<code>usrbuf</code>指向的内存位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_read</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">char</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt;<br><br>    <span class="hljs-keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">/* Refill if buf is empty */</span><br>        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf,<br>                           <span class="hljs-keyword">sizeof</span>(rp-&gt;rio_buf));<br>        <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (errno != EINTR)           <span class="hljs-comment">/* Interrupted by sig handler return */</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt == <span class="hljs-number">0</span>)        <span class="hljs-comment">/* EOF */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="hljs-comment">/* Reset buffer ptr */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */</span><br>    cnt = n;<br>    <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt &lt; n)<br>        cnt = rp-&gt;rio_cnt;<br>    <span class="hljs-built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);<br>    rp-&gt;rio_bufptr += cnt;<br>    rp-&gt;rio_cnt -= cnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	对于一个应用程序，rio_read函数和 Unix read函数有同样的语义。在出错时，它返回值 -1，并且适当地设置errno。在EOF时，它返回值0。如果要求的字节数超过了读缓冲区内未读的字节的数量，它会返回一个不足值。两个函数的相似性使得很容易通过用rio_read代替 read来创建不同类型的带缓冲的读函数。例如，用rioread代替read。</p>
<p>​	实际上，<code>rio_readnb</code>与<code>rio_readn</code>具有完全相同的结构，只不过我们用<code>rio_read</code>替换了<code>read</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;<br>    <span class="hljs-type">ssize_t</span> nread;<br>    <span class="hljs-type">char</span> *bufp = usrbuf;<br><br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">/* errno set by read() */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* EOF */</span><br>        nleft -= nread;<br>        bufp += nread;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (n - nleft); <span class="hljs-comment">/* return &gt;= 0 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似地，<code>rio_readlineb</code>函数从文件<code>rp</code>中读取一个文本行并将其复制到内存中<code>usrbuf</code>指向的位置。循环内每次对<code>rio_read</code>的调用都会把读取缓冲区中的一个字节复制到<code>&amp;c</code>，然后检查它是否是换行符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> maxlen)</span><br>&#123;<br>    <span class="hljs-type">int</span> n, rc;<br>    <span class="hljs-type">char</span> c, *bufp = usrbuf;<br><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">1</span>; n &lt; maxlen; n++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="hljs-number">1</span>)) == <span class="hljs-number">1</span>)<br>        &#123;<br>            *bufp++ = c;  <span class="hljs-comment">/* Copy rp to user buf */</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                n++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* EOF, no data read */</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;    <span class="hljs-comment">/* EOF, some data was read */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Error */</span><br>    &#125;<br>    *bufp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>5.读取文件元数据</h1>
<p>​	应用程序能够通过调用 <code>stat </code>和 <code>fstat</code> 函数，检索到关于文件的信息(有时也称为文件的元数据(metadata))。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>​	函数<code>stat</code>使用文件名<code>*filename</code>作为输入，将信息填写到<code>stat</code>结构体中。<code>fstat</code>与之类似，但它的参数是文件描述符<code>fd</code>。结构体<code>stat</code>如下所示，我们只需关注字段<code>st_mode</code>和<code>st_size</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Metadata returned by the stat and fstat functions */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span>&#123;</span><br>	<span class="hljs-type">dev_t</span>	st_dev;			<span class="hljs-comment">/* Device */</span><br>	<span class="hljs-type">ino_t</span>  	st_ino;			<span class="hljs-comment">/* inode */</span><br>	<span class="hljs-type">mode_t</span> 	st_mode;		<span class="hljs-comment">/* Protection and file type */</span><br>	<span class="hljs-type">nlink_t</span>	st_nlink;		<span class="hljs-comment">/* Number of hard links */</span><br>	<span class="hljs-type">uid_t</span>	st_uid;			<span class="hljs-comment">/*User ID of owner */</span><br>	<span class="hljs-type">gid_t</span>	st_gid;			<span class="hljs-comment">/*Group ID of owner */</span><br>	<span class="hljs-type">dev_t</span>	st_rdev;		<span class="hljs-comment">/*Device type(if inode device)*/</span><br>	<span class="hljs-type">off_t</span>	st_size;		<span class="hljs-comment">/* Total size,in bytes */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blksize;	<span class="hljs-comment">/*Blocksize for filesystem I/O */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blocks;	<span class="hljs-comment">/*Number of blocks allocated */</span><br>	<span class="hljs-type">time_t</span>	st_atime;			<span class="hljs-comment">/* Time of last access */</span><br>	<span class="hljs-type">time_t</span>	st_mtime;			<span class="hljs-comment">/* Time of last modification */</span><br>	<span class="hljs-type">time_t</span>	st_ctime;			<span class="hljs-comment">/* Time of last change */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>​	<code>	st_size</code>包含了文件的大小，而<code>st_mode</code>则包含了文件的访问权限和类型。。Unix识别大量不同的文件类型。<strong>普通文件</strong>包括某种类型<strong>的二进制</strong>或<strong>文本数据</strong>。对于内核而言，文本文件和二进制文件毫无区别。目录文件包含关于其他文件的信息。套接字是一种用来通过网络与其他进程通信的文件。Unix提供的宏指令根据stmode 成员来确定文件的类型。下图列出了这些宏的一个子集。</p>
<p><img src="477e0109e741db37bb3a9148ea7550a6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1>6.读取目录内容</h1>
<p>​	应用程序调用<code>opendir</code>和<code>readdir</code>函数读取目录中的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">// Returns: pointer to handle if OK, NULL on error</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-comment">// Returns: pointer to next directory entry if OK, NULL if no more entries or error</span><br></code></pre></td></tr></table></figure>
<p>​	函数<code>opendir</code>以目录的路径名为参数，返回一个指向目录流（Directory Stream）的指针。流是对有序项目列表的抽象，此处指的是目录中条目的列表。函数<code>readdir</code>返回指向目录流中下一个条目的指针，每个条目都是一个<code>dirent</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    <span class="hljs-type">ino_t</span> d_ino;       <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-type">char</span>  d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* Filename */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>​	<code>d_name</code>是文件名，<code>d_ino</code>是文件的 inode 数。当发生错误时，<code>readdir</code>返回<code>NULL</code>并设置<code>errno</code>。</p>
<p>函数<code>closedir</code>关闭目录流并释放所有相关资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-comment">// Returns: 0 on success, −1 on error</span><br></code></pre></td></tr></table></figure>
<h1>7.共享文件</h1>
<p>​	可以用许多不同的方式来共享 Unix 文件。除非你很清楚内核是如何表示打开的文件，否则文件共享的概念相当难懂。内核用三个相关的数据结构来表示打开的文件:</p>
<ul>
<li>描述符表(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li>
<li>文件表(fle table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成(针对我们的目的)包括有当前的文件位置、引用计数(referencecount)(即当前指向该表项的描述符表项数)，以及一个指向v-node 表中对应表项的指针关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。</li>
<li>v-node 表(v-node table)。同文件表一样，所有的进程共享这张 v-node 表。每个表项包含stat结构中的大多数信息，包括stmode和stsize成员。</li>
</ul>
<p><img src="48a460a8f846d6a45edbb97323e43634.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	上图展示了一个示例，其中描述符1和4通过不同的打开文件表表项来引用两个不同的文件。这是一种典型的情况，没有共享文件，并且每个描述符对应一个不同的文件。</p>
<p><img src="76ae1bed0326e46ffde1e910d3c51f42.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	上图所示，多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，如果以同一个filename 调用 open 函数两次，就会发生这种情况。关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。</p>
<p><img src="04613b08bc1a4dcf88a8b4538e1fb65b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	我们也能理解父子进程是如何共享文件的。假设在调用 fork之前，父进程有如图 10-11所示的打开文件。然后，上图展示了调用fork后的情况。子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个很重要的结果就是在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。</p>
<h1>8.I/O重定向</h1>
<p>​	<code>dup2</code>函数将描述符表条目<code>oldfd</code>复制到<code>newfd</code>并覆盖其原始内容。如果<code>newfd</code>已经打开，则该函数在复制<code>oldfd</code>之前会先关闭<code>newfd</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br><span class="hljs-comment">// Returns: nonnegative descriptor if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>​	假设某进程的打开文件数据结构如上图 10.12 所示。描述符 1（标准输出）指向文件 A（如终端），描述符 4 指向文件 B（如磁盘上的文件），文件 A 和 B 的<code>refcnt</code>均为 1。那么该进程调用函数<code>dup2(4, 1)</code>后情况变为：</p>
<p><img src="b955d5545be0eb6663cfe6168677530b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	文件 A 被关闭，内核会删除其打开文件表和 v-node 表条目。两个描述符均指向文件 B，其<code>refcnt</code>已增加为 2。从现在开始，任何写入到标准输出的数据都会被重定向到文件 B。</p>
<h1>9.标准I/O</h1>
<p>​	ANSI C定义了一组高级输人输出函数，称为标准I0库，为程序员提供了Unix I/0的较高级别的替代。这个库(libc)提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数(fread和 fwrite)、读和写字符串的函数(fgets和 fputs)，以及复杂的格式化的I/O所数(scanf和printf)。<br>
​	标准 IO库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。每个ANSIC程序开始时都有三个打开的流stdin、stdout和stderr，分别对应于标准输人、标准输出和标准错误:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;  <span class="hljs-comment">/* Standard input (descriptor 0) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>; <span class="hljs-comment">/* Standard output (descriptor 1) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>; <span class="hljs-comment">/* Standard error (descriptor 2) */</span><br></code></pre></td></tr></table></figure>
<p>​	类型为 FILE 的流是对文件描述符和流缓冲区的抽象。<strong>流缓冲区</strong>的目的和 RIO 读缓冲区的一样:就是使开销较高的 Unix I/O 系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准 IO的 getc函数，每次调用返回文件的下一个字符。当第一次调用 getc时，库通过调用一次 read 函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc的调用就能直接从流缓冲区得到服务。</p>
<h1>9.综合:我该使用哪些 1/0 函数</h1>
<p>​	Unix I/O、标准 I/O 和 <em>Rio</em> 包函数之间的关系如下图所示：</p>
<p><img src="06e0473c31e4f344d476dc1facdfaa9d.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	那么我们应当使用哪种 I/O 函数呢？以下是一些建议：</p>
<ul>
<li>尽可能使用标准 I/O 函数，它们是在磁盘和终端上执行 I/O 操作的最佳选择；</li>
<li>不要使用<code>scanf</code>或<code>rio_readlineb</code>函数读取二进制文件，它们是专门为读取文本文件设计的；</li>
<li>将标准 I/O 函数用于 <strong>Socket</strong> 时可能会出现一些令人讨厌的问题，因此我们应当在网络编程时使用 <strong><em>Rio</em> 包函数。</strong></li>
</ul>
<h1>总结：</h1>
<p>一切都是文件，都可以用 “”打开open –&gt; 读写write/read –&gt; 关闭close” 模式来操作。输入/输出(I/O) 是指主存和外部设备(如磁盘，终端，网络)之间拷贝数据过程。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
        <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="print-no-link">#阅读笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP_阅读笔记_10_系统级I/O</div>
      <div>http://example.com/2024/09/02/CSAPP-阅读笔记-10-系统级I-O/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>7qing</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月2日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年9月2日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/31/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="CSAPP_阅读笔记_9_虚拟内存">
                        <span class="hidden-mobile">CSAPP_阅读笔记_9_虚拟内存</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","appKey":"IdTuwk7eTRDfLgZzPUknFG0z","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
