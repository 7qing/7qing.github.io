

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="7qing">
  <meta name="keywords" content="">
  
    <meta name="description" content="​	为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间。 虚拟内存有以下三个重要功能：  将主存储器作为磁盘的缓存，只保留主存中的活跃区域并根据需要不断地在两者之间传输数据； 为每个进程提供统一的">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP_阅读笔记_9_虚拟内存">
<meta property="og:url" content="http://example.com/2024/08/31/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="7qing">
<meta property="og:description" content="​	为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间。 虚拟内存有以下三个重要功能：  将主存储器作为磁盘的缓存，只保留主存中的活跃区域并根据需要不断地在两者之间传输数据； 为每个进程提供统一的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/csapp.png">
<meta property="article:published_time" content="2024-08-30T21:21:50.000Z">
<meta property="article:modified_time" content="2024-09-07T09:14:54.444Z">
<meta property="article:author" content="7qing">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="阅读笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/csapp.png">
  
  
  
  <title>CSAPP_阅读笔记_9_虚拟内存 - 7qing</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","app_key":"IdTuwk7eTRDfLgZzPUknFG0z","server_url":"https://j6zz0vra.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>7qing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/backward.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP_阅读笔记_9_虚拟内存"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-31 05:21" pubdate>
          2024年8月31日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          135 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSAPP_阅读笔记_9_虚拟内存</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-09-07T17:14:54+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>​	为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即<strong>虚拟内存（Virtual Memory，VM）</strong>。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间。</p>
<p>虚拟内存有以下三个重要功能：</p>
<ul>
<li>将主存储器作为磁盘的缓存，只保留主存中的活跃区域并根据需要不断地在两者之间传输数据；</li>
<li>为每个进程提供统一的地址空间，从而简化内存管理；</li>
<li>保护每个进程的地址空间不被其他进程所破坏。</li>
</ul>
<p>​	虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地自动地工作的，不需要应用程序员的任何干涉。既然虚拟存储器在幕后工作得如此之好，为什么程序员还需要理解它呢?有以下几个原因:</p>
<ul>
<li>虚拟存储器是中心的。虚拟存储器遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。理解虚拟存储器将帮助你更好地理解系统通常是如何工作的。</li>
<li>虚拟存储器是强大的。虚拟存储器给予应用程序强大的能力，可以创建和销毁存储器片(chunk)、将存储器片映射到磁盘文件的某个部分，以及与其他进程共享存储器。比如，你知道你可以通过读写存储器位置读或者修改一个磁盘文件的内容吗?或者是你可以加载一个文件的内容到存储器中，而不需要进行任何显式的拷贝吗?理解虚拟存储器将帮助你利用它的强大功能在你的应用程序中添加动力。</li>
<li>虚拟存储器是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如 malloc这样的动态分配程序时，它就会和虚拟存储器发生交互。如果虚拟存储器使用不当，应用将遇到复杂危险的与存储器有关的错误。例如，一个带有错误指针的程序可以立即崩溃于“段错误”或者“保护错误”，它可能在崩溃之前还默默地运行几个小时，或者是最令人惊慌地，运行完成却产生不正确的结果。理解虚拟存储器以及诸如malloc之<br>
类的管理虚拟存储器的分配程序，可以帮助你避免这些错误。</li>
</ul>
<h1>1.物理和虚拟寻址</h1>
<p>​	主存中的每个字节都有一个唯一的物理地址（Physical Address，PA），CPU 使用物理地址访问内存的方式被称为物理寻址（Physical Addressing）：</p>
<p><img src="26b4f68fc71ade4aba0f9fadb414b806.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，当CPU执行这条加载指令时，它会生成一个有效物理地址，通过存储器总线，把它传递给主存。主存取出从物理地址4处开始的4字节的字，并将它返回给CPU，CPU 会将它存放在一个寄存器里。</p>
<p>​	CPU 也可以通过<strong>虚拟地址（Virtual Address，VA）<strong>访问主存，只不过该地址在发送到主存之前需要被转换为适当的物理地址。这种寻址方式被称为</strong>虚拟寻址（Virtual Addressing）</strong>：</p>
<p><img src="a530c248a1e28be827d6154add76ea8b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	地址转换（Address Translation ）需要 CPU 硬件和操作系统之间密切合作，位于 CPU 芯片上的内存管理单元（Memory Management Unit，MMU）根据 <strong>页表（Page Table)</strong> 动态地将虚拟地址转换为物理地址。页表存储在主存中，其内容由操作系统维护。</p>
<h1>2.地址空间</h1>
<p>地址空间（Address Space）是一组有序的非负整数地址：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">{0,1,2,...}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span></span></span></span></span></span></p>
<p>如果这些整数是连续的，我们就称其为线性地址空间（Linear Address Space）。在拥有虚拟内存的系统中，CPU 从 n 位线性地址空间中生成虚拟地址，该虚拟地址空间共有 N = 2^n 个地址：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{0,1,2,…,N−1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span></span></span></p>
<p>现代系统通常支持 32 位或 64 位虚拟地址空间。同样地，系统也有一个物理地址空间：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{0,1,2,…,M−1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span></span></span></p>
<p>与虚拟地址空间不同，M 不一定为 2 的幂。但为了简化讨论，我们假设 M = 2^m。</p>
<p>​	地址空间明确地将数据对象（字节）和其属性（地址）区分开来，因此每个数据对象都可以有多个独立的地址，这便是虚拟内存的基本思想。主存中的每个字节都有一个从物理地址空间中选择的物理地址，以及一个从虚拟地址空间中选择的虚拟地址。</p>
<h1>3.虚拟内存作为缓存的工具</h1>
<p>​	概念上而言，虚拟存储器(VM)被组织为<strong>一个由存放在磁盘上的N个连续的字节大小的单元组成的数组</strong>。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘与主存之间以 Block为单位传输数据。而在虚拟内存系统中，Block 被称为虚拟页面（Virtual Page，VP），其大小为 P = 2^p。类似地，物理内存也可以被划分为多个大小为 P 的物理页面（Physical Page，PP)。</p>
<p>虚拟页面有以下三种状态：</p>
<ul>
<li>未分配（Unallocated）：没有被进程申请使用的页面，不占用任何磁盘空间；</li>
<li>未缓存（Uncached）：仅加载到磁盘而未缓存到主存中的页面；</li>
<li>已缓存（Cached）：已缓存在主存中的页面。</li>
</ul>
<p><img src="78e3378142d7dc3ba0c0667c11db5534.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	示例展示了一个有8个虚拟页的小虚拟存储器。虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中。</p>
<h2 id="3-1-DRAM-缓存">3.1 DRAM 缓存</h2>
<p>​	我们将 CPU 和主存之间的 L1、L2 和 L3 级缓存称为 SRAM 缓存，而将主存中用来缓存虚拟页面的缓存称为 DRAM 缓存。</p>
<p>​	与 SRAM 缓存相比，DRAM 缓存发生缓存缺失的成本很高（需要从磁盘中加载数据），因此虚拟页面往往比较大——通常为 4 KB 到 2 MB。DRAM 缓存是全关联型的，这样任何一个虚拟页面都可以放在任何一个物理页面中。</p>
<h2 id="3-2-页表">3.2 页表</h2>
<p>​	页表是由**页表条目（Page Table Entries，PTEs）**组成的数组。每个虚拟页面在页表都有一条 PTE，它在页表中的偏移量是固定的。每条 PTE 中都包含了一个表示该虚拟页面是否已缓存的有效位，以及一个 n 位的地址字段。若有效位为 1，则地址字段是缓存该页面的物理页面的起始地址；若有效位为 0 且地址字段为空，则代表该虚拟页面未分配；若有效位为 0 且地址字段非空，则地址字段是该页面在磁盘上的起始地址。</p>
<p><img src="08794d989540e2d86715fcb19c1fbbf3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如上图所示，系统中存在 8 个虚拟页面和 4 个物理页面：页面 1，2，4 和 7 缓存在 DRAM 中；页面 3 和 6 已分配但未缓存；页面 0 和 5 未分配。</p>
<h2 id="3-3-缺页故障">3.3 缺页故障</h2>
<p>​	我们将访问 DRAM 缓存时发生的缓存缺失称为缺页故障（Page Fault）。若 CPU 引用上图页面 3 中的某个字，地址转换硬件会从主存中读取 PTE 3 ，然后根据其有效位判断出该页面未缓存。缺页故障异常将调用内核中的异常处理程序，选择受害者页面（Victim Page）逐出主存。</p>
<p>在本例中，受害者页面为 VP 4，因此内核会先将 PTE 4 中的有效位重置为 0。如果该页面已发生更改，内核还需要将其复制回磁盘。接下来，内核把 VP 3 从磁盘复制到主存中的 PP 3，并更新 PTE 3 中的有效位。下图展示了异常处理程序返回后示例页表的状态：</p>
<p><img src="59a3848a159eff722efc06f6865881d8.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="3-4-分配页面">3.4 分配页面</h2>
<p><img src="f661330612a1a14c0592c475fb443032.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上图展示了分配一个新的虚拟页面（如进程调用<code>malloc</code>）后页表的变化。操作系统先在磁盘上开辟空间，然后更新 PTE 5 使 VP 5 指向磁盘上新创建的页面。</p>
<div class="note note-secondary">
            <p>​	<strong>又是局部性救了我们</strong>：</p><p>​	当我们中的许多人都了解了虚拟存储器的概念之后，我们的第一印象通常是它的效率应该是非常低的。因为不命中处罚很大，我们会担心页面调度会破坏程序性能。实际上，虚拟存储器工作得相当好，这主要归功于我们的老朋友局部性(locality)。尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集(residentset)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。只要我们的程序有好的时间局部性，虚拟存储器系统就能工作得相当好。但是，当然不是所有的程序都能展现良好的时间局部性。如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸(thrashing)，这时页面将不断地换进换出。虽然虚拟存储器通常是有效的，但是如果一个程序性能慢得像爬一样，那么聪明的程序员会考虑是不是发生了颠簸。</p>
          </div>
<h1>4.虚拟存储器作为存储器管理的工具</h1>
<p>​	操作系统为每个进程都维护了一个单独的页表，因此所有进程都拥有自己的虚拟地址空间：</p>
<p><img src="6d4bdd36d4a88baaf291aa121570fffb.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，进程 i 的页表将 VP 1 映射到 PP 2，将 VP 2 映射到 PP 7；进程 j 的页表将 VP 1 映射到 PP 7，将 VP 2 映射到 PP 10。多个虚拟页面可以映射到同一个共享物理页面。VM简化了链接、加载、代码和数据的共享以及应用程序的内存分配：</p>
<ul>
<li>简化链接：独立的虚拟地址空间允许每个进程使用相同的内存结构，因此链接器无需考虑可执行文件的代码和数据在物理内存中的实际位置。这种统一性极大地简化了链接器的设计和实现；</li>
<li>简化加载：若要将目标文件的 .text 和 .data 段加载到一个新进程的地址空间中，**加载器只需为它们分配虚拟页面，然后将其标记为未缓存，最后再将页表条目指向目标文件中对应的位置。**实际上加载器从未将任何数据从磁盘复制到主存中，代码和数据只有在被第一次引用时才会按需分页；</li>
</ul>
<p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称做<strong>存储器映射(memory mapping)</strong>。Unix提供一个称为 mmap 的系统调用，允许应用程序自己做存储器映射。</p>
<ul>
<li>简化共享：操作系统可以将不同进程中的不同虚拟页面映射到相同的物理页面，从而实现进程之间代码和数据的共享；</li>
<li>简化内存分配：当应用程序申请额外的内存时，<strong>操作系统会为其分配一定数量的连续虚拟页面</strong>，然后将它们映射到任意位置的物理页面。这些物理页面无需连续，并且可以在物理内存中随机分布。</li>
</ul>
<h1>5.虚拟存储器作为存储器保护的工具</h1>
<p>​</p>
<p>​	任何现代计算机系统必须为操作系统提供手段来控制对存储器系统的访问。不应该允许一个用户进程修改它的只读文本段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有存储器，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做(通过调用明确的进程间通信系统调用)。</p>
<p>​	我们可以在 PTE 中添加一些权限位来管理进程对页面的访问：</p>
<p><img src="2a27b556d0d4e6997e14bf78f398bf65.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，SUP 表示是否只有在内核态运行的进程才能访问该页面，READ 和 WRITE 则分别表示页面是否可读写。例如，进程 i 在用户态中运行，那么它可以读取 VP 0，读取和写入 VP 1，但无法访问 VP 2。</p>
<p>​	如果某条指令违反了上述权限，CPU 就会触发通用保护故障，并将控制权转移到内核中的异常处理程序。该处理程序会向问题进程发送一个 SIGSEGV 信号，Linux Shell 通常将此异常报告为<strong>分段故障（Segmentation Fault）</strong>。</p>
<h1>6.地址翻译</h1>
<p><img src="bedce0d3cdd7c195fbd7a4222e86012b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	形式上来说，地址翻译是一个N元素的虚拟地址空间(VAS)中的元素和一个M元素的物理地址空间(PAS)中元素之间的映射。</p>
<p><strong>MAP(A)</strong></p>
<ul>
<li>
<p>A’          如果虚拟地址A处的数据在PAS的物理地址A’处</p>
</li>
<li>
<p>NULL    如果虚拟地址A处的数据不在物理存储器中</p>
</li>
</ul>
<p><img src="05efaef3d69509139b96bba236ad1e18.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	CPU 中的<strong>页表基址寄存器（Page Table Base Register ，PTBR</strong>）指向当前页表，n 位的虚拟地址由 p 位的虚拟页面**偏移量（Virtual Page Offset，VPO）<strong>和 n-p 位的</strong>虚拟页面编号（Virtual Page Number，VPN）<strong>组成。MMU 根据 VPN 的值选择对应的 PTE，如 VPN 0 选择 PTE 0，VPN 1 选择 PTE 1。由于物理页面和虚拟页面的大小相同，VPO 与物理页面偏移量（Physical Page Offset，PPO）也就相同，因此页表条目中的</strong>物理页面编号（Physical Page Number，PPN）**与 <strong>VPO</strong> 共同组成了转换后的物理地址。</p>
<p><img src="e8dfc363d9805b4ffed7f102c8132d3f.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上图展示了页面命中时的 CPU 硬件操作步骤：</p>
<ol>
<li>处理器生成一个虚拟地址 VA 并发送到 MMU；</li>
<li>MMU 生成 PTE 地址 PTEA 并向高速缓存或主存发起请求；</li>
<li>高速缓存或主存将 PTE 返回给 MMU；</li>
<li>MMU 构造物理地址 PA 并将其发送到高速缓存或主存；</li>
<li>高速缓存或主存将请求的数据返回给处理器。</li>
</ol>
<p><img src="278546386ea435a680d242580f4b3408.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上图展示了缺页故障时的 CPU 硬件操作步骤：</p>
<ol>
<li>处理器生成一个虚拟地址 VA 并发送到 MMU；</li>
<li>MMU 生成 PTE 地址 PTEA 并向高速缓存或主存发起请求；</li>
<li>高速缓存或主存将 PTE 返回给 MMU；</li>
<li>PTE 中的有效位为 0，因此 MMU 触发异常并将控制权转移给内核中的异常处理程序；</li>
<li>处理程序从物理内存中选取受害者页面换出。若该页面已被修改，则还要将其复制到磁盘中；</li>
<li>处理程序将新页面换入并更新 PTE；</li>
<li>处理程序返回到原来的进程，之前引发缺页故障的指令重新执行。此时进程请求的页面已缓存，因此 CPU 随后的操作与页面命中时相同。</li>
</ol>
<h2 id="6-1-结合高速缓存和虚拟存储器">6.1 结合高速缓存和虚拟存储器</h2>
<p>​	大部分同时使用虚拟内存和高速缓存（SRAM 缓存）的系统均采用物理寻址的方式访问高速缓存。下图展示了两者的集成方式：</p>
<ul>
<li>注意： 页表条目可以缓存</li>
</ul>
<p><img src="1dba5da0850b59d43fb8ff2b0cb67d2e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="6-2-利用TLB加速地址翻译">6.2 利用TLB加速地址翻译</h2>
<p>​	CPU 每次生成虚拟地址时，MMU 都必须引用 PTE 才能完成地址转换。如果 PTE 位于主存而非高速缓存中，那么地址转换的速度将大大下降。大多数系统的 MMU 中包含了一个被称为**转换后备缓冲区（Translation Lookaside Buffer，TLB）**的小型 PTE 缓存，其每个缓存行中都有一个由单条 PTE 组成的 Block。用于集合选择和行匹配 的 Set Index 和 Tag 是从虚拟地址的 VPN 中提取的：<br>
<img src="6846577427e658025b185ad379fed5b7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如果 TLB 有 T = 2^<em>t</em> 个集合，则 Set Index（TLBI）由 VPN 中 t 个最低位组成，Tag（TLBT）由 VPN 中的剩余高位组成。</p>
<p><img src="7ef9aea621bed462fe8e94175e3fa767.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	上图展示了 TLB 命中时的 CPU 硬件操作步骤。由于地址转换均在 CPU 芯片上的 MMU 中执行，因此速度很快：</p>
<ol>
<li>CPU 生成一个虚拟地址 VA；</li>
<li>MMU 向 TLB 发送 VPN 以请求 PTE；</li>
<li>TLB 将 PTE 返回给 MMU；</li>
<li>MMU 将虚拟地址转换为物理地址 PA 并发送到高速缓存或主存；</li>
<li>高速缓存或主存将请求的数据返回给处理器。</li>
</ol>
<p><img src="55eeea9b46270d2a06c450bf6288ab50.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上图展示了 TLB 未命中时的 CPU 硬件操作步骤。MMU 必须从高速缓存或主存中获取 PTE 并将其存储在 TLB 中，这可能会覆盖现有条目。</p>
<h2 id="6-3-多级页表">6.3 多级页表</h2>
<p>在之前的讨论中，我们假设系统只使用单级页表进行地址转换。但如果地址空间有 32 位，一个页面 4 KB 并且一条 PTE 4 字节。那么即使应用程序只引用一小部分虚拟内存，我们也需要一个 4 MB 的页表常驻在内存中：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>=</mo><mn>32</mn><mo separator="true">,</mo><mi>P</mi><mo>=</mo><mn>4</mn><mi>K</mi><mo>=</mo><msup><mn>2</mn><mn>12</mn></msup><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">(</mo><mi>P</mi><mi>T</mi><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mi>p</mi></mrow></msup><mo>=</mo><mn>220</mn><mo>=</mo><mn>1</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">n=32,P=4K=2^{12},n(PTE)=2^{np}=220=1M
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">32</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">PTE</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">220</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p>我们可以通过对页表分级来压缩页表的大小：</p>
<p><img src="0a2376af0cff698d6e0e70a617542cf0.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，一级页表中有 1024 条 PTE，每条 PTE 都映射到一个包含 1024 个连续虚拟页面的地址空间块。每个地址空间块的大小为 1024 * 4 KB = 4 MB，因此 1024 条 PTE 就可以覆盖 32 位（4 MB * 1024 = 4 GB = 2^{32} B）地址空间。</p>
<p>​	如果地址空间块中的所有页面均未分配，则一级页表中对应的 PTE 为空（如上图中的 PTE 2～7）；如果地址空间块中至少有一个页面已分配，那么一级页表中对应的 PTE 就指向二级页表中该块的起始位置（如上图中的 PTE 0～1）。二级页表中的每条 PTE 都映射到一个 4 KB 的物理内存页，这与我们之前查看的单级页表相同。</p>
<p>​	若一级页表中的 PTE 为空，那么二级页表内对应的条目就无需存在。多数应用程序的虚拟地址空间中大部分页面是未分配的，因此这将显著地降低页表的内存占用。另外，我们只需在主存中维护一级页表和被调用最为频繁的二级页表，其它的二级页表可以由操作系统按需创建和分页。</p>
<p><img src="7cd1ee52bc8ebf139d2503ba2b63c4d0.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	在 k 级页表中，虚拟地址被划分为 k 个 VPN 和一个 VPO，VPN i（1 ≤ i ≤ k）是第 i 级页表的索引。除第 k 级页表外，每个页表中的 PTE 均指向下一级页表的起始位置，而第 k 级表内的每条 PTE 则保存了对应物理页面的 PPN。与单级页表一样，PPO 与 VPO 相同。MMU 必须先请求 k 个 PTE，然后才能确定 PPN 以生成完整的物理地址。TLB 可以缓存多级页表中的 PTE，这使得多级页表的地址转换速度并不比单级页表慢很多。</p>
<h1>7.Intel Core i7/Linux 内存系统</h1>
<p>​	尽管底层的 Haswell 微架构能够支持完整的 64 位虚拟和物理地址空间，但目前 Core i7 仅提供了 48 位 (256 TB) 的虚拟地址空间和 52 位 (4 PB ) 的物理地址空间，以及一个支持 32 位 (4 GB) 虚拟和物理地址空间的兼容模式。</p>
<p>​	下图给出了Core i7存储器系统的重要部分。**处理器包(processor package)**包括四个核，一个大的所有核共享的L3高速缓存，以及一个 DDR3 存储器控制器。每个核包含一个层次结构的 TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点连接，这种连接是基于Imntel QuickPath 技术的，是为了让一个核与其他核和外部IO桥直接通信。TLB 是虚拟寻址的,是四路组相连的。L1、L2和L3高速缓存是物理寻址的，是八路组相连的，块大小为64字节页大小在启动时被配置为4KB或4MB。Linux 使用的是4KB的页。</p>
<p><img src="16835a2054533f03604c76375313baca.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="7-1-Core-i7-地址翻译">7.1 Core i7 地址翻译</h2>
<p><img src="428c933bfea1e39ff826172866228239.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，Core i7 使用四级页表结构。CR 3 控制寄存器中保存了一级 (L1) 页表的起始物理地址，其值是每个进程上下文的一部分并在上下文切换时恢复。48 位的虚拟地址包含了 36 位的 VPN 和 12 位（4 K = 2^{12}）的 VPO，其中 VPN 又被划分为四个 9 位的地址空间块。</p>
<h2 id="7-2-Linux虚拟内存系统">7.2 Linux虚拟内存系统</h2>
<p><img src="c0247360aa69b9ba4972369cdb2c4a4b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	内核虚拟存储器包含内核中的代码和数据结构。内核虚拟存储器的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构**。有趣的是，Linux也将一组连续的虚拟页面(大小等于系统中DRAM的总量)映射到相应的一组连续的物理页面**。这就为内核提供了一种便利的方法来访问物理存储器中任何特定的位置，例如，当它需要访间页表，或在一些设备上执行存储器映射的 I/O 操作，而这些设备被映射到特定的物理存储器位置时。</p>
<p>​	内核虚拟存储器的其他区域包含每个进程都不相同的数据。例如，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h3 id="1-Linux虚拟存储器区域">1. Linux虚拟存储器区域</h3>
<p>​	  Linux 将虚拟内存划分为多个区域或段（Area 或 Segment），每个区域都是一些已分配且在某些方面相关的连续页面(chunk)。例如，代码段、数据段、堆、共享库段和用户栈分别是不同的区域。每个已分配的页面都属于某个区域，因此不属于任何区域的页面不存在也无法被进程引用。区域概念的引入使得 Linux 允许虚拟地址空间存在间隙.</p>
<p><img src="d58c9760f89607eb642b9d8ab19b8ab5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，Linux 内核为每个进程维护了一个独特的数据结构<code>task_struct</code>，其字段包含或指向内核运行该进程所需的全部信息（如 PID、用户栈指针、可执行目标文件名称和程序寄存器等）。</p>
<p>​	其中，字段<code>mm</code>指向<code>mm_struct</code>，该结构体描述了虚拟内存的当前状态。<code>mm_struct</code>中的<code>pgd</code>字段指向一级页表的起始位置，它在进程运行时被内核存储在 CR 3 控制寄存器中。而<code>mmap</code>字段则指向一个由<code>vm_area_structs</code>组成的链表。描述区域信息的结构体<code>vm_area_structs</code>包含以下字段：</p>
<ul>
<li><code>vm_start</code>：指向区域的起点；</li>
<li><code>vm_end</code>：指向区域的末端；</li>
<li><code>vm_prot</code>：描述该区域中所有页面的读/写权限；</li>
<li><code>vm_flags</code>：描述该区域中的页面是否与其他进程共享；</li>
<li><code>vm_next</code>：指向链表中下一个<code>vm_area_structs</code>。</li>
</ul>
<h3 id="2-linux缺页异常处理">2. linux缺页异常处理</h3>
<p>​	假设 MMU在试图翻译某个虚拟地址 A时，触发了一个缺页。这个异常导致控制转移到内<br>
核的缺页处理程序，处理程序随后就执行下面的步骤:</p>
<ol>
<li>
<p>虚拟地址 A是合法的吗?换句话说，A在某个区域结构定义的区域内吗?为了回答这个问题，的缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end 做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这种情况在下图中标识为“1”。</p>
<p>因为一个进程可以创建任意数量的新虚拟存储器区域(使用在下一节中描述的 mmap 函数)，<br>
所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux 使用某些我们没有显示出<br>
来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。</p>
</li>
<li>
<p>试图进行的存储器访问是否合法?换句话说，进程是否有读、写或者执行这个区域内页<br>
面的权限?例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令<br>
造成的?这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟存储器中读取字造成<br>
的?如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进<br>
程。这种情况在图 9-28 中标识为“2”。</p>
</li>
<li>
<p>此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样<br>
来处理这个缺页的:选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换<br>
人新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将<br>
再次发送 A到 MMU。这次，MMU就能正常地翻译 A，而不会再产生缺页中断了。</p>
</li>
</ol>
<p><img src="78785d4bdb449b4051d3f00015fe1cc4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1>8. 内存映射</h1>
<p>​	Linux 使用内存映射（Memory Mapping）技术初始化虚拟内存区域并将其与磁盘上的“对象”相关联。该“对象”有两种类型：</p>
<ol>
<li>
<p>文件系统中的常规文件（Regular File）：文件被分成多个与页面大小相同的片段，而每个片段都包含了一个虚拟页面的初始内容。由于操作系统采用按需分页的策略，因此页面在第一次被 CPU 引用前不会被换入到物理内存中。如果虚拟内存区域比文件大，则多余部分用零填充；</p>
</li>
<li>
<p>匿名文件（Anonymous File）：由内核创建，其内容全部为二进制零。当 CPU 第一次引用该区域内的虚拟页面时，内核会先在物理内存中选择一个合适的受害者页面（若该页面已被修改则需要将其换出）并用二进制零将其覆盖，然后更新页表使虚拟页面指向被覆盖后的物理页面。整个过程中没有数据被换入到物理内存，因此该区域内的页面又被称为零需求页面（Demand-zero Page）。</p>
</li>
</ol>
<p>一旦我们使用内存映射初始化一个虚拟页面，它就会在由内核维护的交换文件（Swap File）与物理内存之间来回交换。交换文件又称交换区（Swap Area）或交换空间（Swap Space），<strong>它的大小限制了当前运行进程所能申请的虚拟页面总量</strong>。</p>
<h2 id="8-1-再看共享对象">8.1 再看共享对象</h2>
<p>​	存储器映射的概念来源于一个聪明的发现:如果虚拟存储器系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到存储器中的方法。<br>
​	正如我们已经看到的，进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。不过，许多进程有同样的只读文本区域。例如，每个运行Unix 外壳程序 tcsh 的进程都有相同的文本区域。而且，许多程序需要访问只读运行时库代码的相同拷贝。例如，每个C程序都需要来自标准C库的诸如printf这样的函数。那么，如果每个进程都在物理存储器中保持这些常用代码的复制拷贝，那就是极端的浪费了。幸运的是，存储器映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。<br>
​	一个对象可以被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>
​	另一方面，对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p>
<p><img src="0e5322bba76ef59fea5b50f2c15c93be.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，两进程将相同的 共享目标文件映射到各自虚拟地址空间中的不同区域，而物理内存中只需存在单个文件副本。进程 1 对该共享区域的任何写入操作都对进程 2 可见，并且这些更改还会同步到磁盘上的原始文件。</p>
<p><img src="7c36b3fdf6d7f1ed5e62f62b4f25001e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图 (a) 所示，两进程将私有目标文件映射到各自虚拟地址空间的不同区域。进程 1 对该私有区域的任何写入操作都对进程 2 不可见，并且这些更改也不会同步到磁盘上的原始文件。如上图 (b) 所示，当进程 2 试图修改该区域中的内容时，<strong>内核会在物理内存中为页面创建一个新副本并更新页表条目使其指向它</strong>。由于页面复制发生在写入操作前，这种技术被称为<strong>写时复制（Copy-on-Write）</strong>，这些区域则是<strong>私有写时复制的（Private Copy-on-Write）</strong>。</p>
<h2 id="8-2-再看fork函数">8.2 再看<code>fork</code>函数</h2>
<p>​	进程调用 <code>fork</code> 函数后，内核会为子进程分配一个唯一的 PID 并为其创建与父进程相同的<code>mm_struct</code>、<code>vm_area_structs</code>以及页表。当任意进程后续执行写入操作时，内核将使用写时复制技术创建新页面，这便保证了进程虚拟地址空间的私有性。</p>
<h2 id="8-3-再看execve函数">8.3 再看<code>execve</code>函数</h2>
<p>​	如果进程调用 <code>execve</code> 函数，如<code>execve(&quot;a.out&quot;, NULL, NULL)</code>，则加载并运行<code>a.out</code>的步骤如下：</p>
<ol>
<li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址空间中用户区域的<code>vm_area_structs</code>；</li>
<li><strong>映射私有区域</strong>。为新程序的代码、数据、bss 和堆栈区域创建<code>vm_area_structs</code>。这些区域都是私有写时复制的，代码和数据区域被映射到<code>a.out</code>文件中的 <a target="_blank" rel="noopener" href="https://koktlzz.github.io/posts/linking-note/#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">.text 和 .data</a>，bss 区域则被映射到大小包含在<code>a.out</code>内的匿名文件。堆栈的初始长度均为 0，其页面是零需求的；</li>
<li><strong>映射共享区域</strong>。如果<code>a.out</code>文件链接了共享库，如 C 标准库<code>libc.so</code>，那么还需要把这些对象动态链接到程序中，并将其映射到虚拟地址空间中的共享区域内；</li>
<li><strong>设置程序计数器(PC)</strong>。使当前进程上下文中的程序计数器指向新程序代码区域的入口点。</li>
</ol>
<p><img src="845975a26f00fa721b45a14beed48223.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="8-4-使用-mmap-函数的用户级存储器映射">8.4 使用 <code>mmap</code> 函数的用户级存储器映射</h2>
<p>Linux 进程可以使用 mmap 函数来创建新的虚拟存储器区域，并将对象映射到这些区域中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span>  *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">// Returns: pointer to mapped area if OK, MAP_FAILED (−1) on error</span><br></code></pre></td></tr></table></figure>
<p>​	<code>mmap</code>函数请求内核创建一个起始地址为参数<code>start</code>的虚拟内存区域，该区域映射到文件描述符<code>fd</code>所指定的对象。连续对象的长度为参数<code>length</code>，其首部在文件中的偏移量为参数<code>offset</code>：</p>
<p><img src="6c7bf93e529ee550e548321ea3bb87a6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>参数<code>prot</code>中包含了描述虚拟内存区域访问权限的位，即<code>vm_area_structs</code>中的<code>vm_prot</code>：</p>
<ul>
<li><code>PROT_EXEC</code>：该区域中的页面包含可执行指令；</li>
<li><code>PROT_READ</code>：可以阅读该区域中的页面；</li>
<li><code>PROT_WRITE</code>：可以写入该区域中的页面；</li>
<li><code>PROT_NONE</code>：无法访问该区域中的页面。</li>
</ul>
<p>参数<code>flag</code>中包含了描述了映射对象类型的位：</p>
<ul>
<li><code>MAP_SHARED</code>：共享对象；</li>
<li><code>MAP_PRIVATE</code>：私有写时复制对象；</li>
<li><code>MAP_ANON</code>：匿名对象，对应的虚拟页面是零需求页面。</li>
</ul>
<p>​	让内核创建一个新的包含 size 字节的只读、私有、请求二进制零的虚拟存储器区域。如果调用成功，那么 bufp 包含新区域的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bufp=Mmap(<span class="hljs-number">-1</span>,Size,PROT_READ，MAP_PRIVATEIMAP_ANON，O，<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p><code>munmap</code>函数删除起始于虚拟地址<code>start</code>、长度为<code>length</code>的区域，后续对已删除区域的引用会引发分段故障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure>
<h1>9.动态内存分配</h1>
<p>​	虽然可以使用低级的mmap和munmap函数来创建和删除虚拟存储器的区域，但是C程序员还是会觉得当运行时需要额外虚拟存储器时，用**动态存储器分配器(dyamic memory allocator)**来创建虚拟内存区域。更方便，也有更好的可移植性。</p>
<p><strong>动态内存分配器为进程维护的虚拟内存区域被称为堆（Heap）</strong>，其一般结构为：</p>
<p><img src="88b3e2b633102a7fb450f185f304b3d4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	<strong>堆向上增长</strong>，内核为每个进程都维护了一个指向堆顶的变量<code>brk</code>。分配器将堆看作一个包含<strong>不同尺寸 Block 的集合</strong>，<strong>每个 Block 都是一个连续的虚拟内存块</strong>。Block 有两种状态，已分配（Allocated）和空闲（Free）。所有分配器均显式地为应用程序分配 Block，但负责释放已分配 Block 的实体可能有所不同：</p>
<ul>
<li><strong>显式分配器</strong>：应用程序显式地释放已分配的 Block。C 和 C++ 程序分别调用<code>malloc</code>和<code>new</code>函数请求 Block，调用<code>free</code>和<code>delete</code>函数释放 Block；</li>
<li><strong>隐式分配器</strong>：分配器自行释放程序不再使用的已分配 Block，该过程被称为<strong>垃圾回收（Garbage Collection）</strong>。Lisp、ML 和 Java 等高级语言均采用这种方法。</li>
</ul>
<p>​	本节剩下的部分讨论的是显式分配器的设计和实现。我们将在下一节中讨论隐式分配器。为了更具体，我们的讨论集中于管理堆存储器的分配器。然而，应该明白存储器分配是一个普遍的概念，可以出现在各种上下文中。例如，图形处理密集的应用程序就经常使用标准分配器来要求获得一大块虚拟存储器，然后使用与应用相关的分配器来管理块中的存储器，以支持图形节点的创建和销毁。</p>
<h2 id="9-1-malloc和free函数">9.1 malloc和free函数</h2>
<pre><code class="hljs">C标准库提供了一个称为malloc程序包的显式分配器。程序通过调用malloc函数来从堆中分配块。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// Returns: pointer to allocated block if OK, NULL on error</span><br></code></pre></td></tr></table></figure>
<p>​	<code>malloc</code>函数请求堆中的一块 Block 并返回指向该 Block 的指针。Block 的大小至少为参数<code>size</code>，并可能根据其保存的数据对象类型进行适当对齐。在 32 位编译模式下，Block 的地址始终为 8 的倍数，而在 64 位中则为 16 的倍数。如果执行<code>malloc</code>遇到问题，如程序请求的 Block 大小超过了可用的虚拟内存，则函数返回<code>NULL</code>并设置 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/errno.3.html"><code>errno</code></a>。我们还可以使用<code>malloc</code>的包装函数<code>calloc</code>，它会将分配的内存初始化为零。类似地，<code>realloc</code>函数可以更改已分配 Block 的大小</p>
<p>​</p>
<p>​	还可以使用<code>sbrk</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> incr)</span>;<br><span class="hljs-comment">// Returns: old brk pointer on success, −1 on error</span><br></code></pre></td></tr></table></figure>
<p>​	<code>sbrk</code>函数将参数<code>incr</code>与内核中的<code>brk</code>指针相加以增大或缩小堆。若执行成功，则返回<code>brk</code>的旧值，否则将返回 -1 并将<code>errno</code>设置为<code>ENOMEM</code>。</p>
<p>​	程序通过调用<code>free</code>函数来释放已分配的堆块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br><span class="hljs-comment">// Returns: nothing</span><br></code></pre></td></tr></table></figure>
<p>​	<code>free</code>函数将参数<code>ptr</code>指向的 Block 释放，而这些 Block 必须是由<code>malloc</code>、<code>calloc</code>或<code>realloc</code>分配的。该函数没有返回值，因此很容易产生一些令人费解的运行时错误。</p>
<p><img src="ed12d6c6d8d77d14f4befcb68d01c124.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上图展示了 C 程序如何使用<code>malloc</code>和<code>free</code>管理一个大小为 16 字（字长为 4 字节）的堆。图中的每个方框代表一个字，每个被粗线分隔的矩形代表一个 Block。有阴影的 Block 代表已分配，无阴影的 Block 则代表空闲。</p>
<ul>
<li>如上图 (a) 所示，程序请求一个 4 字的 Block，<code>malloc</code>从空闲块中切出一个 4 字的 Block 并返回指向该 Block 中第一个字的指针<code>p1</code>；</li>
<li>如上图 (b) 所示，程序请求一个 5 字的 Block，<code>malloc</code>从空闲块中切出一个 6 字的 Block 以实现双字对齐；</li>
<li>如上图 © 所示，程序请求一个 6 字的 Block，<code>malloc</code>从空闲块中切出一个 6 字的 Block；</li>
<li>如上图 (d) 所示，程序释放图 (b) 中分配的 Block。<code>free</code>返回后，指针<code>p2</code>依然指向已释放的 Block，因此程序不应在重新初始化<code>p2</code>前继续使用它；</li>
<li>如上图 (e) 所示，程序请求一个 2 字的 Block。<code>malloc</code>从上一步释放的 Block 中切出一部分并返回指向新 Block 的指针<code>p4</code>。</li>
</ul>
<h2 id="9-2-动态内存分配的原因">9.2 动态内存分配的原因</h2>
<p>​	在程序实际运行之前，我们可能并不知道某些数据结构的大小。程序使用动态存储器分配的最重要的原因是<strong>经常直到程序实际运行时，它们才知道某些数据结构的大小</strong>。示例 C 程序将<code>n</code>个 ASCII 整型从标准输入读取到数组<code>array[MAXN]</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 15213</span><br><br><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[MAXN];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">if</span> (n &gt; MAXN)<br>        app_error(<span class="hljs-string">&quot;Input file too big&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;<span class="hljs-built_in">array</span>[i]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	由于我们无法预测<code>n</code>的值，因此只能将数组大小写死为<code>MAXN</code>。<code>MAXN</code>的值是任意的，可能超出系统可用的虚拟内存量。另外，一旦程序想要读取一个比<code>MAXN</code>还大的文件，唯一的办法就是增大<code>MAXN</code>的值并重新编译程序。如果我们在运行时根据<code>n</code>的大小动态分配内存，以上问题便迎刃而解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>, i, n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">array</span> = (<span class="hljs-type">int</span> *)Malloc(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;<span class="hljs-built_in">array</span>[i]);<br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">array</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-3-对分配器的要求和目标">9.3 对分配器的要求和目标</h2>
<p>显式分配器必须在若干限制条件下运行：</p>
<ul>
<li>处理任意顺序的请求：分配器不能对<code>malloc</code>和<code>free</code>的请求顺序作出假设。例如，分配器不能假设所有的<code>malloc</code>都紧跟一个与之匹配的<code>free</code>；</li>
<li>立即响应请求：分配器不可以对请求重新排序或缓冲（Buffer）以提高性能；</li>
<li>仅使用堆：分配器使用的数据结构必须存储在堆中；</li>
<li>对齐 Block：分配器必须对齐 Block 以使其能够容纳任何类型的数据对象；</li>
<li>不修改已分配的 Block：分配器无法修改、移动或压缩已分配的 Block。</li>
</ul>
<p>衡量分配器性能的指标有：</p>
<ul>
<li>吞吐量（Throughput）：单位时间内完成的请求数；</li>
<li>内存利用率（Memory Utilization）：即堆内存的使用率。</li>
</ul>
<p>最大化吞吐量和最大化内存利用率之间存在矛盾，因此我们在设计分配器时需要找到二者的平衡。</p>
<h2 id="9-4-碎片">9.4 碎片</h2>
<p>​</p>
<p>​	造成堆利用率很低的主要原因是一种称为**碎片(fagmentation)**的现象，当虽然有未使用的存储器但不能用来满足分配请求时，就会发生这种现象。有两种形式的碎片:<strong>内部碎片(intermalfragmentation)<strong>和</strong>外部碎片(external fragmentation)</strong>。</p>
<ul>
<li>内部碎片（Internal Fragmentation）：已分配的 Block 比进程请求的 Block（即 Payload）大，通常因分配器为满足对齐要求而产生；</li>
<li>外部碎片（External Fragmentation）：空闲内存充足但却没有空闲的 Block 能够满足分配请求。例如堆中有 4 个空闲的字且分布在两个不相邻的 Block 上，此时若进程申请一个 4 字的 Block 就会出现外部碎片。</li>
</ul>
<p>​	内部碎片很容易量化，因为它只是已分配 Block 与 Payload 之间大小差异的总和，其数量仅取决于先前的请求模式和分配器的实现方式；外部碎片则难以量化，因为它还要受到未来请求模式的影响。为了减少外部碎片的产生，分配器力求维护少量较大的空闲 Block 而非大量较小的空闲 Block。</p>
<h2 id="9-5-实现难点">9.5 实现难点</h2>
<p>​</p>
<p>​	我们可以想象出的最简单的分配器会把堆组织成一个大的字节数组，还有一个指针p，初始指向这个数组的第一个字节。为了分配size个字节，malloc将p的当前值保存在栈里，将p增加size，并将p的旧值返回到调用函数。free 只是简单地返回到调用函数，而不做其他任何事情。<br>
​	这个简单的分配器是设计中的一种极端情况。因为每个ma1loc和 free只执行很少量的指吞吐率会极好。然而，因为分配器从不重复使用任何块，存储器利用率将极差。一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题:</p>
<ul>
<li>空闲块组织:我们如何记录空闲块?</li>
<li>放置:我们如何选择一个合适的空闲块来放置一个新分配的块?</li>
<li>分割:在我们将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分?</li>
<li>合并:我们如何处理一个刚刚被释放的块?本节剩下的部分将更详细地讨论这些问题。因为像放置、分割以及合并这样的基本技术贯穿在许多不同的空闲块组织中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。</li>
</ul>
<h2 id="9-6-隐式空闲链表">9.6 隐式空闲链表</h2>
<p>​	大多数分配器通过将一些数据结构嵌入到 Block 中以分辨其<strong>边界和状态</strong>，例如：</p>
<p><img src="f4db00fff25920c010449ef777dcc779.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如上图所示，Block 由一个单字（四字节）的<strong>头部（Header）</strong>、有效负载（Payload）和一些额外**填充（Padding）**组成，头部中包含了 Block 的大小（Block Size）和状态信息（Allocated or Free）。如果系统采用双字对齐策略，那么每个 Block 的大小始终为 8 的倍数，其二进制表达的后 3 位始终为 0。因此我们可以仅在头部中存储该字段的前 29 位，剩余 3 位用来存储其他信息。上图中的位“a”便指示了此 Block 是已分配的还是空闲的。填充的大小是任意的，它可能是分配器为了避免外部碎片产生而设置的，也可能是为了满足对齐要求而存在的。</p>
<p>例如，假设我们有已分配的块，大小为24(0x18)字节。那么它的头部将是:</p>
<p><code>0x00000018|0x1=0x00000019</code></p>
<p>类似地，一个块大小为 40(0x28)字节的空闲块有如下的头部:</p>
<p><code>0x00000028|0x0=0x00000028</code></p>
<p>​	头部后面就是应用调用malloc 时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因，比如，填充可能是分配器策略的一部分，用来对付外部碎片，或者也需要用它来满足对齐要求。</p>
<p>基于这种 Block 格式，我们可以将堆组织成一系列连续的已分配 Block 和空闲 Block：</p>
<p><img src="758e1ded8db1b51f85a0c00b1f2ac2fc.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	Block 通过其头部中的<strong>大小字段隐式地链接起来</strong>（addr(next_block) = addr(current_block) + block_size），因此我们将这种堆组织方式称为隐式空闲链表（Implicit Free List），分配器必须遍历堆中所有的 Block 才能得到全部空闲的 Block。我们还需要一个特殊的 Block 以标记堆的结尾，如上图中的 “0/1”。隐式空闲链表的优点是简单，但任何搜索空闲 Block 的操作（如放置新分配的 Block）的成本都与堆中 Block 的总数成正比。</p>
<h2 id="9-7-放置新分配的-Block">9.7 放置新分配的 Block</h2>
<p>​	分配器搜索空闲链表，查找一个足够大可以放置所请求当一个应用请求一个k字节的块时，块的空闲块。分配器执行这种搜索的方式是由<strong>放置策略(placement policy)<strong>确定的。一些常见的策略是</strong>首次造配(frst fit)</strong>、<strong>下一次适配(next fit)<strong>和</strong>最佳适配(best fit)</strong>:</p>
<ul>
<li>第一次拟合（First Fit）：从头开始遍历空闲链表并选择第一个满足条件的 Block；</li>
<li>下一次拟合（Next Fit）：从上一次搜索停止的地方开始遍历空闲链表并选择第一个满足条件的 Block；</li>
<li>最佳拟合（Best Fit）：遍历所有 Block 并选择满足条件且最小的 Block</li>
</ul>
<p>第一次拟合的优点是较大的 Block 通常存留在链表末尾，但一些较小的 Block 也会散落在链表开头，这将增加搜索较大 Block 的时间。如果链表开头存在大量较小的 Block，下一次拟合就比第一次拟合快很多。然而研究表明，下一次拟合的内存利用率比第一次拟合低。最佳拟合的内存利用率通常比其他两种策略高，但对隐式空闲链表来说，其搜索时间显然要比它们慢很多。</p>
<h2 id="9-8-分割空闲的-Block">9.8 分割空闲的 Block</h2>
<p>​	如果分配器找到了合适的 Block 并将整个 Block 分配给程序，就有可能产生内部碎片。为了避免这一问题，分配器可以将选取的 Block 分成一个已分配的 Block 和一个新的空闲 Block：</p>
<p>​	然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。下图展示了分配器如何分割8个字的空闲块，来满足一个应用的对堆存储器3个字的请求：</p>
<p><img src="a76b3b1566d8c2fde6add934ebbfc7b4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="9-9-获取额外的堆内存">9.9 获取额外的堆内存</h2>
<p>​	如果分配器无法找到合适的 Block，它可以尝试将<strong>物理相邻的空闲 Block 合并以获取更大的 Block</strong>。但如果仍然无法满足请求，分配器便会调用<code>sbrk</code>函数向内核请求额外的堆内存并将其转换为一个新的空闲 Block。</p>
<h2 id="9-10-合并空闲的-Block">9.10 合并空闲的 Block</h2>
<p>​	当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做<strong>假碎片(fault fragmentation)</strong>，就是有许多可用的空闲块被切割成小的、无法使用的空闲块。比如，下图展示了释放图 9-37中分配的块后得到的结果：</p>
<p><img src="97dc0e2fe0e88d58d80de31739a9dd1e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	结果是两个相邻的空闲块，每一个的有效载荷都为3个字。因此，接下来一个对4个字有效载荷的请求就会失败，即使两个空闲块的合计大小足够大，可以满足这个请求。</p>
<p>​	为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并(coalescing)。这就出现了一个重要的策略决定，那就是何时执行合并。分配器可以选择<strong>立即合并(immediate coalescing)</strong>，也就是在每次一个块被释放时，就合并所有的相邻块。或者它也可以选择<strong>推迟合并(deferred coalescing)</strong>，也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。</p>
<p>​	立即合并很简单明了，可以在常数时间内执行完成，但是对于某些请求模式，<strong>这种方式会产生一种形式的抖动，块会反复地合并</strong>，然后马上分割。例如，在图9-38中，反复地分配和释放一个3个字的块将产生大量不必要的分割和合并。在对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某<strong>种形式的推迟合并</strong>。</p>
<h2 id="9-11-带边界标记的合并">9.11 带边界标记的合并</h2>
<p>​	我们把即将释放的 Block 称为<strong>当前块（Current Block）</strong>，其头部指向下一个 Block 的头部（addr(next_block) = addr(current_block) + block_size）。因此我们很容易判断下一个 Block 是否空闲，并且只需将当前 Block 头部中的大小字段与之相加即可完成合并。</p>
<p>​	但若要合并上一个 Block，我们只能遍历整个链表，并在到达当前 Block 前不断记下上一个 Block 的位置。因此对于隐式空闲链表，每次调用<code>free</code>函数，合并上一个 Block 的时间与堆内存的大小成正比。</p>
<p>​	我们可以在每个 Block 末尾都添加一个头部的副本以使合并 Block 的时间变为常数，这种技术被称为边界标记（Boundary Tags）：</p>
<p><img src="e1c09f1f69199ea680604743b875c0e4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	上一个 Block 的尾部始终与当前 Block 的头部相距一个字长，因此分配器可以通过检查上一个 Block 的尾部来确定其位置和状态。</p>
<p>考虑当分配器释放当前块时所有可能存在的情况:</p>
<ol>
<li>前面的块和后面的块都是已分配的。</li>
<li>前面的块是已分配的，后面的块是空闲的。</li>
<li>前面的块是空闲的，而后面的块是已分配的，</li>
<li>前面的和后面的块都是空闲的。</li>
</ol>
<p>​	下图展示了分配器是如何使用边界标记合并 Block 的：</p>
<p><img src="8a5a3119d483b10be0f532b074385573.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>在情况1中，两个邻接的块都是已分配的，因此不可能进行合并。所以当前块的状态只是简单地从已分配变成空闲。</li>
<li>在情况2中，当前块与后面的块合并。用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。</li>
<li>在情况3中，前面的块和当前块合并。用两个块大小的和来更新前面块的头部和当前块的脚部。</li>
<li>在情况4中，要合并所有的三个块形成一个单独的空闲块，用三个块大小的和来更新前面块的头部和后面块的脚部。在每种情况中，合并都是在常数时间内完成的。</li>
</ol>
<p>​	由于每个 Block 都包含头部和尾部，当 Block 数量较多时，边界标记显著地增加了内存的开销。<strong>考虑到分配器只有在上一个 Block 空闲时才需要获取其尾部内的 Block 大小</strong>，因此我们可以将上一个 Block 的状态存储在当前 Block 头部的<strong>多余低位中</strong>，这样已分配的 Block 便不需要尾部了。</p>
<h2 id="9-12-显式空闲链表">9.12 显式空闲链表</h2>
<p>​	由于分配 Block 的时间与 Block 的总数成正比，隐式空闲链表不适用于通用分配器。我们可以在每个空闲 Block 中加入一个指向上一个空闲 Block 的前驱（Predecessor）指针和一个指向下一个空闲 Block 的后继（Successor）指针，这样堆的组织结构就变成了一个双向链表，我们称其为显式空闲链表（Explicit Free List）。</p>
<p><img src="805594378ff24f425c41a550224902d6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	如果采用第一次拟合策略，显式空闲链表分配 Block 的时间与空闲 Block 的数量成正比，而释放 Block 的时间则取决于空闲 Block 的排序方式：</p>
<ul>
<li>后进先出（Last-in First-out，LIFO）：将刚被释放的 Block 插入到链表开头，因此释放 Block 的时间为常数，并且可以通过边界标记使合并 Block 的时间也为常数；</li>
<li>按地址顺序（Address Order）：使链表中每个 Block 的地址均小于其后继 Block 的地址。在这种情况下，释放 Block 需要一定的时间来寻找合适的位置，但堆内存的利用率比后进先出高。</li>
</ul>
<p>显式空闲链表的缺点在于指针的引入增加了空闲 Block 的大小，这将增大<strong>内部碎片</strong>发生的可能性。</p>
<h2 id="9-13-分离式空闲链表">9.13 分离式空闲链表</h2>
<p>​	就像我们已经看到的，一个使用单向空闲块链表的分配器需要与空闲块数量呈线性关系的时间来分配块。一种流行的减少分配时间的方法，通常称为<strong>分离存储(segregatedstorage)</strong>，就是维护<strong>多个空闲链表</strong>，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做<strong>大小类(size class)</strong>。有很多种方式来定义大小类。例如，我们可以根据2的幂来划分块大小:</p>
<p>​					<strong>{1},{2},{3,4},{5–8},…,{1025–2048},{2049–4096},{4097–∞}</strong></p>
<p>也可以让每个较小的 Block 独自成为一个大小类，较大的 Block 依然按 2 的幂划分：</p>
<p>​					<strong>{1},{2},{3},…,{1024},{1025–2048},{2049–4096},{4097–∞}</strong></p>
<p>​	每个空闲链表都属于某个大小类，因此我们可以将堆看成一个按大小类递增的空闲链表数组。当进程请求一个 Block 时，分配器会根据其大小在适当的空闲链表中搜索。如果找不到满足要求的 Block，它便会继续搜索下一个链表。</p>
<p>​	不同的分离式空闲链表在定义大小类的方式、合并 Block 的时机以及是否允许分割 Block 等方面有所不同，其中最基本的两种类型为<strong>简单分离存储（Simple Segregated Storage）<strong>和</strong>分离适配（Segregated Fits）</strong>。</p>
<ol>
<li>简单分离存储</li>
</ol>
<p>​	在简单分离存储中，空闲链表内每个 Block 的大小均等于其所属大小类中最大的元素。如某个大小类为 {17-32}，则其对应的空闲链表中 Block 的大小都是 32。当进程请求一个 Block 时，分配器选取满足请求的空闲链表并分配其中第一个 Block；当某个 Block 被释放后，分配器将其插入到合适的空闲链表前面。因此，简单分离存储分配和释放 Block 的时间均为常量。</p>
<p>​	一个显著的缺点是，简单分离存储很容易造成内部和外部碎片。因为空闲块是不会被分割的，所以可能会造成内部碎片。更糟的是，因为不会合并空闲块，所以某些引用模式会引起极多的外部碎片。</p>
<ol start="2">
<li>分离适配</li>
</ol>
<p>​	使用分离适配方法，分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有许多种不同的分离适配分配器。这里，我们描述了一种简单的版本。</p>
<p>​	为了分配一个块，我们必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果我们找到了一个，那么我们(可选地)分割它，并将剩余的部分插入到适当的空闲链表中。如果我们找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么我们就向操作系统请求额外的堆存储器，从这个新的堆存储器中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。</p>
<p>​	分离适配方法是一种常见的选择，C标准库中提供的GNU <code>malloc</code>包就是采用的这种方法因为这种方法既快速，对存储器的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部分，而不是整个堆。存储器利用率得到了改善，因为有一个有趣的事实:对分离空闲链表的简单的首次适配搜索，其存储器利用率近似于对整个堆的最佳适配搜索的存储器利用率。</p>
<p>​	3. 伙伴系统</p>
<p>​	伙伴系统(buddy system)是分离适配的一种特例，其中每个大小类都是2的幂。基本的思路是假设一个堆的大小为2&quot;个字，我们为每个块大小2“维护一个分离空闲链表，其中0&lt;k≤m。请求块大小向上舍人到最接近的2的幂。最开始时，只有一个大小为 2&quot;个字的空闲块。<br>
​	为了分配一个大小为2“的块，我们找到第一个可用的、大小为2的块，其中k≤j≤ m。如果j=k，那么我们就完成了。否则，我们递归地二分割这个块，直到j=k。当我们进行这样的分割时，每个剩下的半块(也叫做伙伴)被放置在相应的空闲链表中。要释放一个大小为2的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，我们就停止合并。关于伙伴系统的一个关键事实是，给定地址和块的大小，很容易计算出它的伙伴的地址。例如，一个块大小为 32字节，地址为：</p>
<p>​	xxx…x00000<br>
它的伙伴的地址为：<br>
​	xxx…x10000<br>
换句话说，一个块的地址和它的伙伴的地址只有一位不相同，伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为2的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些特定应用的工作负载，其中块大小预先知道是2的幂，伙伴系统分配器就很有吸引力了。</p>
<h1>10. 垃圾收集</h1>
<p>​	垃圾回收器（Garbage Collector）是一种动态存储分配器，它会自动释放程序不再需要的 Block（垃圾）。</p>
<h2 id="10-1-垃圾收集器的基本知识">10.1 垃圾收集器的基本知识</h2>
<p>​</p>
<p>​	垃圾回收器将内存看作一个有向可达性图：</p>
<p><img src="ad931fca0fb534e66d367e94bd7d525d.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	图中的节点被分为一组根节点（Root Nodes）和一组堆节点（Heap Nodes），每个堆节点都对应于一个堆中已分配的 Block。有向边 <em>p</em>→<em>q</em>表示 Block <em>p</em> 中的某个位置指向 Block <em>q</em> 中的某个位置。根节点对应于不在堆中却包含了指向堆的指针的位置，这些位置可以是寄存器、栈中的变量或可读写数据区域中的全局变量。</p>
<p>​	如果根节点与堆节点之间存在一条有向路径，我们就称该堆节点是<strong>可达的（Reachable）</strong>。在任何时刻，不可达的节点都与程序不再使用的 Block 对应。垃圾回收器<strong>定期释放</strong>不可达节点并将其返回到空闲链表。</p>
<p>​	ML 和 Java 等语言的垃圾回收器对应用程序使用指针的方式进行了严格的限制，因此它可以维护一个精确的可达性图，从而回收所有的垃圾。而 C 和 C++ 等语言的垃圾回收器则无法保证可达性图的精确性，一些不可达的节点可能被错误地识别为可达的，我们称其为<strong>保守垃圾回收器（Conservative Garbage Collector）</strong>。</p>
<p>​	收集器可以按需提供它们的服务，或者它们可以作为一个和应用并行的独立线程，不断地更新可达图和回收垃圾。例如，考虑如何将一个C程序的保守的收集器加入到已存在的malloc包中，如图所示：</p>
<p><img src="180d20d57ac10a4c1e76571cec65ab1e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	无论何时需要堆空间，应用都会用通常的方式调用malloc。如果 malloc 找不到一个合适的空闲块，那么它就调用垃圾收集器，希望能够回收一些垃圾到空闲链表。收集器识别出垃圾块，并通过调用 free函数将它们返回给堆。关键的思想是收集器代替应用去调用free。当对收集器的调用返回时，malloc重试，试图发现一个合适的空闲块。如果还是失败了，那么它就会向操作系统要求额外的存储器。最后，malloc返回一个指向请求块的指针(如果成功)或者返回一个空指针(如果不成功)。</p>
<h2 id="10-2-Mark-Sweep-垃圾收集器">10.2 Mark&amp;Sweep 垃圾收集器</h2>
<p>Mark&amp;Sweep 是常用的垃圾回收算法之一，它分为两个阶段：</p>
<ul>
<li>标记（Mark）阶段：标记所有可达的根节点后代。通常我们将 Block 头部的多余低位之一用于指示该 Block 是否被标记；</li>
<li>清除（Sweep）阶段：释放所有未标记且已分配的 Block</li>
</ul>
<p>为了更好地理解 Mark&amp;Sweep 算法，我们作出以下假设：</p>
<ul>
<li><code>ptr</code>：由<code>typedef void *ptr</code>定义的类型；</li>
<li><code>ptr isPtr(ptr p)</code>：若<code>p</code>指向已分配 Block 中的某个字，则返回指向该 Block 起始位置的指针<code>b</code>，否则返回<code>NULL</code>；</li>
<li><code>int blockMarked(ptr b)</code>：如果该 Block 已被标记则返回<code>true</code>；</li>
<li><code>int blockAllocated(ptr b)</code>：如果该 Block 已分配则返回<code>true</code>；</li>
<li><code>void markBlock(ptr b)</code>：标记 Block；</li>
<li><code>int length(ptr b)</code>：返回 Block 除头部外的字长；</li>
<li><code>void unmarkBlock(ptr b)</code>：将 Block 的状态从已标记转换为未标记；</li>
<li><code>ptr nextBlock(ptr b)</code>：返回指向下一个 Block 的指针。</li>
</ul>
<p>那么此算法就可以用下图中的伪码表示:</p>
<p><img src="bb2f274c0af56a0404d20277955af535.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	在标记阶段，垃圾回收器为每个根节点调用一次<code>mark</code>函数。若<code>p</code>未指向已分配且未标记的 Block，则该函数直接返回。否则，它标记该 Block 并将其中的每个字作为参数递归地调用自身（<code>mark(b[i])</code>）。此阶段结束时，任何未标记且已分配的 Block 都是不可达的；在扫描阶段，垃圾回收器只调用一次<code>sweep</code>函数。该函数遍历堆中的每一个 Block，释放所有已分配且未标记的 Block。</p>
<p><img src="498b2bceec9f573c81c483527665374a.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>​	上图中的每个方框代表一个字，每个被粗线分隔的矩形代表一个 Block，而每个 Block 都有一个单字的头部。最初，堆中有 6 个已分配且未标记的 Block。Block 3 中包含指向 Block 1 的指针，Block 4 中包含指向 Block 3 和 6 的指针。根节点指向 Block 4，因此 Block 1、3、4 和 6 从根节点可达，它们会被垃圾回收器标记。在扫描阶段完成后，剩余不可达的 Block 2 和 5 将被释放。</p>
<h1>小结：</h1>
<p>设计一个malloc和gc（在后面的博客中我会贴出）</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
        <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="print-no-link">#阅读笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP_阅读笔记_9_虚拟内存</div>
      <div>http://example.com/2024/08/31/CSAPP-阅读笔记-9-虚拟内存/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>7qing</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月31日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年9月7日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/02/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-10-%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/" title="CSAPP_阅读笔记_10_系统级I/O">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSAPP_阅读笔记_10_系统级I/O</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/30/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP_阅读笔记_8_异常控制流">
                        <span class="hidden-mobile">CSAPP_阅读笔记_8_异常控制流</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","appKey":"IdTuwk7eTRDfLgZzPUknFG0z","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
