

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="7qing">
  <meta name="keywords" content="">
  
    <meta name="description" content="​	在计算机的运行过程中，程序计数器依次指向一系列的值：a0,a1,…,an。其中，ak 是其对应指令 Ik 的地址。从 ak* 到 ak+1 的转换被称为控制转移（Control Transfer），一系列的控制转移则被称为处理器的控制流（Control Flow）。 ​	最简单的控制流便是程序中的指令按顺序执行，即 Ik 与 Ik+1 在内存中相邻。不过，这种“平滑”的控制流通常因指令的跳转、">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP_阅读笔记_8_异常控制流">
<meta property="og:url" content="http://example.com/2024/08/30/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.html">
<meta property="og:site_name" content="7qing">
<meta property="og:description" content="​	在计算机的运行过程中，程序计数器依次指向一系列的值：a0,a1,…,an。其中，ak 是其对应指令 Ik 的地址。从 ak* 到 ak+1 的转换被称为控制转移（Control Transfer），一系列的控制转移则被称为处理器的控制流（Control Flow）。 ​	最简单的控制流便是程序中的指令按顺序执行，即 Ik 与 Ik+1 在内存中相邻。不过，这种“平滑”的控制流通常因指令的跳转、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/7qing.png">
<meta property="article:published_time" content="2024-08-29T21:04:16.000Z">
<meta property="article:modified_time" content="2024-08-30T20:17:30.430Z">
<meta property="article:author" content="7qing">
<meta property="article:tag" content="阅读笔记">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/7qing.png">
  
  
  
  <title>CSAPP_阅读笔记_8_异常控制流 - 7qing</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","app_key":"IdTuwk7eTRDfLgZzPUknFG0z","server_url":"https://j6zz0vra.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>7qing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/backward.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP_阅读笔记_8_异常控制流"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-30 05:04" pubdate>
          2024年8月30日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          107 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSAPP_阅读笔记_8_异常控制流</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-08-31T04:17:30+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>​	在计算机的运行过程中，程序计数器依次指向一系列的值：<em>a0,a1,…,an</em>。其中，<em>ak</em> 是其对应指令 <em>Ik</em> 的地址。从 ak* 到 <em>ak</em>+1 的转换被称为<strong>控制转移（Control Transfer）</strong>，一系列的控制转移则被称为<strong>处理器的控制流（Control Flow）</strong>。</p>
<p>​	最简单的控制流便是程序中的指令按顺序执行，即 <em>Ik</em> 与 <em>Ik+1</em> 在内存中相邻。不过，这种“平滑”的控制流通常因指令的跳转、调用和返回而突然改变，此时 <em>Ik</em> 便不再与 <em>Ik+1</em> 相邻。</p>
<p>​	<strong>程序内部的状态是由程序变量表示的</strong>，控制流使得程序可以对其更新做出反应。但系统还必须能够应对自身状态的变化，它们无法被内部程序变量捕获，甚至不一定与程序的执行有关。比如，数据包在到达网络适配器后需要被存储到内存中；程序请求磁盘中的数据时需要得知其何时可用；父进程必须在其子进程终止时收到通知等。</p>
<p>现代系统通过<strong>异常控制流（Exceptional Control Flow，ECF）</strong>来处理上述情况，它应用于计算机系统的所有级别中。</p>
<ul>
<li>比如在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。</li>
<li>在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。</li>
<li>在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</li>
</ul>
<div class="note note-secondary">
            <p>作为程序员，理解 ECF 很重要，这有很多原因:</p><ul><li>理解ECF将帮助你理解重要的系统概念。ECF是操作系统用来实现IO、进程和虚拟存储器的基本机制。在能够真正理解这些重要概念之前，你必须理解 ECF。</li><li>理解ECF 将帮助你理解应用程序是如何与操作系统交互的。应用程序通过使用一个叫做陷阱(trap)或者系统调用(systemcall)的ECF形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解是如何向应用提供这些服务的理解ECF将帮助你编写有趣的新应用程序。操作系统为应用程序提供了强大的ECF机制用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。如果你理解这些 ECF机制，那么你就能用它们来编写诸如 Unix 外壳和 Web 服务器之类的有趣程序了。</li><li>理解 ECF 将帮助你理解并发。ECF是计算机系统中实现并发的基本机制。中断应用程序、进程和线程(它们的执行在时间上是重叠的)执行的异常处理程序和中断应用程序执行的信号处理程序都是在运行中的并发的例子。理解ECF是理解并发的第一步。我们会在第12 章中更详细地研究并发。</li><li>理解 ECF 将帮助你理解软件异常如何工作。像C+ 和Java这样的语言通过 try、catch 以及throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转(违反通常的调用&#x2F;返回栈规则的跳转)来响应错误情况。非本地跳转是一种应用层ECF，在C中是通过setimp和 longjmp 函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。</li></ul>
          </div>



<h1 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h1><p>​	<strong>异常（Exception）</strong>是为了响应处理器状态改变而在控制流中突然发生的变化，其基本思想如下图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/4b1aeafc00f074c455db1328b70d86cf.png" srcset="/img/loading.gif" lazyload></p>
<p>​	处理器状态的变化被称为<strong>事件（Event）</strong>，它可能与当前指令（<em>Icurr</em>）的执行直接相关，比如算术溢出或除数为零；也可能与当前指令的执行无关，比如系统计时器关闭或 I&#x2F;O 请求完成。</p>
<h2 id="1-1-异常处理"><a href="#1-1-异常处理" class="headerlink" title="1.1 异常处理"></a>1.1 异常处理</h2><p>​	异常处理涉及到软件和硬件的密切合作，因此很容易将不同组件执行的工作相混淆。系统中每种可能的异常都对应了一个唯一的非负整数，即<strong>异常数字（Exception Number）</strong>。当计算机系统启动时，操作系统会初始化一个跳转表，也称<strong>异常表（Exception Table）</strong>。异常数字是异常表的索引，其中的每个条目 k 均包含了异常 k 的处理程序地址,异常表的格式格式如图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/f54bd5d2165b4e0c7d4c4f155306f4a7.png" srcset="/img/loading.gif" lazyload></p>
<p>​	异常表的起始地址放在一个叫做<strong>异常表基址寄存器(exception table base register)<strong>的特殊CPU 寄存器里，当处理器检测到事件的发生时，首先将确定异常数字，然后根据异常表进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的</strong>操作系统子程序(异常处理程序(exception handler))</strong> 。调用过程如图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/bf678f8a3d619f1ce6e8fb3edac5e7ae.png" srcset="/img/loading.gif" lazyload></p>
<p>异常与过程调用类似，但也有一些重要区别：</p>
<ul>
<li>异常的返回地址要么是当前指令（<em>Icurr</em>），要么是下一条指令（<em>Inext</em>）；</li>
<li>处理器还会将一些额外的处理器状态信息压入栈中。当处理程序返回后，这些信息是重启被中断程序所必需的；</li>
<li>异常处理程序在内核态运行，因此可以访问所有系统资源</li>
</ul>
<h2 id="1-2-异常的分类"><a href="#1-2-异常的分类" class="headerlink" title="1.2 异常的分类"></a>1.2 异常的分类</h2><p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/8b5f71e1c11db0b5a93f3e534bca3dd8.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h3><p>​	<strong>中断（Interrupt）</strong>异步发生，因为它是由处理器外部的 I&#x2F;O 设备发出的信号产生的。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/2c8d40e058dfb01af8705778057184a3.png" srcset="/img/loading.gif" lazyload></p>
<p>​	当前指令执行完毕后，处理器注意到中断引脚变高，于是从系统总线读取异常数字，然后调用对应的中断处理程序。当处理程序返回时，它将控制权返回给下一条指令。随后程序继续执行，就好像中断从未发生过一样。</p>
<p>其余几种异常作为当前指令的执行结果<strong>同步发生</strong>，我们称之为<strong>故障指令（Faulting Instruction）</strong>。</p>
<h3 id="2-陷阱和系统调用"><a href="#2-陷阱和系统调用" class="headerlink" title="2.陷阱和系统调用"></a>2.陷阱和系统调用</h3><p>​	<strong>陷阱（Trap）</strong>是<strong>有意</strong>的异常，是执行一条指令的结果。与中断处理程序一样，陷阱处理程序也将控制返回给下一条指令。其最重要的用途是在用户程序和内核之间提供接口，即<strong>系统调用（System Call）</strong>。</p>
<p>​	用户程序通过系统调用向内核请求服务，如读取文件（<code>read</code>）、创建新进程（<code>fork</code>）、加载新程序（<code>execve</code>）和终止当前进程（<code>exit</code>）等。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/04a892ee33872e2cb91694b94f67b74b.png" srcset="/img/loading.gif" lazyload></p>
<p>​	在程序员看来，系统调用和常规函数没有什么区别。但常规函数运行在**用户态(user mode)<strong>，因此其可执行的指令类型受限，也只能访问用户栈。而系统调用运行在</strong>内核态(kernel mode)**，能够执行特权指令并访问内核栈。</p>
<h3 id="3-故障"><a href="#3-故障" class="headerlink" title="3.故障"></a>3.故障</h3><p><strong>故障（Faulting）</strong>是由一些错误状况引起的异常，而这些错误情况有可能被处理程序修正，否则将返回到内核中的中止例程（图中的“abort”）：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/ea2f4d53d9c773d236c43ab3228cf316.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-中止"><a href="#4-中止" class="headerlink" title="4.中止"></a>4.中止</h3><p>与故障相比，引发中止（Abort）的错误状况无法挽救。通常是硬件出现问题，如 RAM 位损坏引起的奇偶校验错误。中止处理程序永远不会将控制权返回给应用程序：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/d74c0fa7b9e720f42ef509078eb3c973.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="1-3-Linux-x86-64-系统中的异常"><a href="#1-3-Linux-x86-64-系统中的异常" class="headerlink" title="1.3 Linux&#x2F;x86-64 系统中的异常"></a>1.3 Linux&#x2F;x86-64 系统中的异常</h2><table>
<thead>
<tr>
<th align="center">Exception Number</th>
<th align="center">Description</th>
<th align="center">Exception Class</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">Divide Error</td>
<td align="center">Fault</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">General Protection Fault</td>
<td align="center">Fault</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">Page Fault</td>
<td align="center">Fault</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">Machine Check</td>
<td align="center">Abort</td>
</tr>
<tr>
<td align="center">32-255</td>
<td align="center">OS-defined Exception</td>
<td align="center">Interrupt or Trap</td>
</tr>
</tbody></table>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/ddc0bc7038e66dca8a8b96a41a8f0dab.png" srcset="/img/loading.gif" lazyload alt="中文版"></p>
<ul>
<li>除法故障（Divide Error）：当应用程序尝试除以 0 或除法指令的结果对目标操作数来说太大时，就会发生除法故障。Unix 不会试图纠正除法故障，而是直接中止程序；</li>
<li>一般保护故障（General Protection Fault）：一般保护故障出现的原因有很多，通常是程序引用了未定义的虚拟内存区域，或试图向只读文本段写入。Linux 不会试图纠正该故障，而 Shell 一般将其报告为分段故障（Segmentation Faults）；</li>
<li>缺页故障（Page Fault）：程序引用不在内存而在磁盘上的虚拟页面会导致缺页故障。处理程序将磁盘上合适的虚拟内存页面映射到物理内存页面，然后重新执行故障指令；</li>
<li>机器检查（Machine Check）：一旦系统在执行指令期间检测到致命的硬件错误，便会发生机器检查。处理程序永远不会将控制权返回给应用程序。</li>
</ul>
<h2 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h2><p>x86-64<br><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/20220213214429.png" srcset="/img/loading.gif" lazyload alt="Linux/x86-64 的系统调用"></p>
<p>IA32<br><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/99ac5a2a8e16aad2548d4232b21078c6.png" srcset="/img/loading.gif" lazyload alt="Linux/IA32 的系统调用"></p>
<p>上图中的每个系统调用都有一个唯一的数字，对应了内核中跳转表的偏移量。</p>
<ul>
<li>注意，该跳转表与上文提到的异常表不同。</li>
</ul>
<p>​	C 标准库为大多数系统调用提供了一组包装函数（Wrapper Function），它们比直接使用系统调用更加方便。系统调用及其相关的包装函数被统称为系统级函数。举例来说，我们可以使用系统级函数<code>write</code>代替<code>printf</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello, world\n&quot;</span>, <span class="hljs-number">13</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​	X86-64 系统通过<code>syscall</code>指令使用系统调用，其所有参数均通过寄存器传递。按照惯例，寄存器 %rax 保存系统调用编号，寄存器 %rdi、%rsi、%rdx、%r10、%r8 和 %r9 依次保存各参数的值。系统调用的返回值将写入到寄存器 %rax 中，若为负则表示发生了与负<code>errno</code>相关的错误。因此，上面的程序可以直接用汇编语言表示为：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/20220213221637.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><p>​	异常是允许操作系统提供**进程(process)**的概念所需要的基本构造块，进程是计算机科学中最深刻最成功的概念之一。<br>​	当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。我们的程序好像是独占地使用处理器和存储器。处理器就好像是无间断地一条接一条地执行程序中的指令。最后，我们程序中的代码和数据好像是系统存储器中唯一的对象。这些假象都是通过进程的概念提供给我们的。</p>
<p>​	进程是正在执行的程序的实例，系统中的每个程序都在进程的**上下文(context)**中运行。上下文由程序正确运行所需的状态组成，包括存储在内存中的程序代码和数据、栈、通用寄存器中的内容、程序计数器、环境变量以及打开 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_descriptor">文件描述符</a> 。</p>
<p>进程为应用提供了两个关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，让我们产生程序独占处理器的错觉；</li>
<li>一个私有的地址空间，让我们产生程序独占内存的错觉。</li>
</ul>
<h2 id="2-1-逻辑控制流"><a href="#2-1-逻辑控制流" class="headerlink" title="2.1 逻辑控制流"></a>2.1 逻辑控制流</h2><p>​	即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做逻辑控制流，或者简称<strong>逻辑流</strong>。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/bbbb9e617557b2f9d8020ed515f93d3d.png" srcset="/img/loading.gif" lazyload></p>
<p>进程轮流使用处理器。每个进程执行其流程的一部分，然后在其他进程执行时被<strong>抢占(preempted)（即暂时挂起）</strong>。</p>
<h2 id="2-2-并发流"><a href="#2-2-并发流" class="headerlink" title="2.2 并发流"></a>2.2 并发流</h2><p>​	一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流(Concurrent Flow)<strong>，这两个流被称为并发地运行。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始,或者Y在X开始之后和X结束之前开始。例如，在图8-12中，进程A和B并发地运行，A和C也一样。另一方面，B和C没有并发地运行，</strong>因为B的最后一条指令在C的第一条指令之前执行。</strong><br>​	多个流并发地执行的一般现象称为<strong>并发(concurrency)<strong>。一个进程和其他进程轮流运行的概念称为</strong>多任务(multitasking)<strong>。一个进程执行它的控制流的一部分的每一时间段叫做</strong>时间片(time slice)<strong>。因此，多任务也叫做</strong>时间分片(time slicing)<strong>。<br>​	注意，并发的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。然而，有时我们会发现确认并行流是很有帮助的，它是</strong>并发流的一个真子集</strong>。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为**并行流(parallel fow)**，它们并行地运行(runninginparallel)，且并行地执行(parallel execution)。</p>
<h2 id="2-3-私有地址空间"><a href="#2-3-私有地址空间" class="headerlink" title="2.3 私有地址空间"></a>2.3 私有地址空间</h2><p>​	进程为程序提供了独享的私有地址空间，与空间内特定地址相关的内存字节通常不能被其他任何进程读取或写入。尽管私有地址空间的内容不同，但其具有相同的组织结构（图中的“%esp”应为“%rsp”）：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/359ff97e4360fe3385dbe5369f5fadd8.png" srcset="/img/loading.gif" lazyload></p>
<p>​	地址空间底部是为用户程序保留的，代码段总是从地址 0x400000 开始。地址空间顶部是为内核保留的，包含了内核为进程执行指令（如系统调用）时使用的代码、数据和栈。</p>
<h2 id="2-4-用户模式和内核模式"><a href="#2-4-用户模式和内核模式" class="headerlink" title="2.4 用户模式和内核模式"></a>2.4 用户模式和内核模式</h2><p>​	处理器通过保存在控制寄存器中的模式位（Mode Bit）来识别进程当前享有的特权。当模式位被设置时，进程运行在内核态（Kernel Mode），反之则运行在用户态（User Mode）。在内核态中运行的程序可以执行指令集中的任意指令，并且能够访问系统中的任意位置。而在用户态中运行的程序则受到限制，只能使用系统调用间接地访问内核代码和数据。</p>
<p>​	应用程序的进程只能通过异常来从用户态切换到内核态。当异常发生且控制转移到异常处理程序时，处理器切换到内核态。随后异常处理程序在内核态中运行，处理器将在它返回时切换回用户态。</p>
<p>​	Linux提供了一种聪明的机制，叫做&#x2F;proc 文件系统，它允许用户模式进程访问内核数据结构的内容。&#x2F;proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用&#x2F;proc文件系统找出一般的系统属性，如CPU类型(&#x2F;proc&#x2F;cpuinfo)，或者某个特殊的进程使用的存储器段(&#x2F;proc&#x2F;<process id>&#x2F;maps)。2.6版本的 Limux 内核引人 &#x2F;sys 文件系统，它输出关于系统总线和设备的额外的低层信息。</p>
<h2 id="2-5-上下文切换"><a href="#2-5-上下文切换" class="headerlink" title="2.5 上下文切换"></a>2.5 上下文切换</h2><p>​	内核为每个进程维持一个**上下文(context)**。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>​	在进程执行期间，内核可以暂时挂起当前进程并重启先前被抢占的进程，这一行为被称为<strong>调度（Scheduling）</strong>，是由内核中称为<strong>调度器(scheduler)<strong>的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，内核调度新进程是通过</strong>上下文切换（Context Switch）</strong>机制来实现的，该机制：</p>
<ul>
<li>保存当前进程的上下文；</li>
<li>恢复之前被抢占进程的上下文；</li>
<li>将控制权转移给新进程。</li>
</ul>
<p>​	程序执行系统调用时可能会发生上下文切换。比如系统调用<code>read</code>需要访问磁盘中的数据，内核可以通过上下文切换来调度另一个进程，这样就无需等待数据从磁盘加载到内存中。</p>
<p>​	中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，典型的为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间了，并切换到一个新的进程。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/36335ce328791991ef540186329e22cb.png" srcset="/img/loading.gif" lazyload></p>
<p>​	该图展示了一对进程A和 B之间上下文切换的示例。在这个例子中，初始地，进程A运行在用户模式中，直到它通过执行系统调用read陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到存储器的数据传输后，磁盘中断处理器。</p>
<p>​	磁盘取数据要用一段相对较长的时间(数量级为几十毫秒)，所以内核执行从进程A到进程B的上下文切换，而不是在这个间歇时间内等待，什么都不做。注意在切换之前，内核正代表进程A在用户模式下执行指令。在切换的第一部分中，内核代表进程A在内核模式下执行指令。然后在某一时刻，它开始代表进程B(仍然是内核模式下)执行指令。在切换之后，内核代表进程 B在用户模式下执行指令。</p>
<p>​	随后，进程B在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了存储器。内核判定进程B已经运行了足够长的时间了，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用read之后的那条指令。进程A继续运行，直到下一次异常发生，依此类推。</p>
<div class="note note-secondary">
            <p><strong>高速缓存污染(pollution)和异常控制流</strong></p><p>​	一般而言，硬件高速缓存存储器不能和诸如中断和上下文切换这样的异常控制流很好地交互。如果当前进程被一个中断暂时中断，那么对于中断处理程序来说高速缓存是冷的(cold)译者注:“高速缓存是冷的”意思是程序所需要的数据都不在高速缓存中)。如果处理程序从主存中访问了足够多的表项，那么当被中断的进程继续时，高速缓存对它来说也是冷的了。在这种情况下，我们就说中断处理程序污染(pollute)了高速缓存。使用上下文切换也会发生类似的现象。当一个进程在上下文切换后继续执行时，高速缓存对于应用程序而言也是冷的，必须再次热身。</p>
          </div>



<h1 id="3-系统调用错误处理"><a href="#3-系统调用错误处理" class="headerlink" title="3.系统调用错误处理"></a>3.系统调用错误处理</h1><p>​	当执行 Unix 系统级函数遇到错误时，它们会返回 -1 并设置全局整型变量<code>errno</code>的值。因此我们可以在程序中检查调用是否发生错误，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork error: %s\n&quot;</span>, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>strerror</code>函数会根据<code>errno</code>的值返回相关的文本字符串。我们定义一个<strong>错误报告（Error-reporting）函数</strong>以简化上述代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span> <span class="hljs-comment">/* Unix-style error */</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>    unix_error(<span class="hljs-string">&quot;fork error&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们还可以进一步地将代码简化为一个<strong>错误处理（Error-handling）</strong>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br>pid = Fork();<br></code></pre></td></tr></table></figure>

<p>​	这样我们便能够使用包装函数<code>Fork</code>代替<code>fork</code>及其错误检查代码。本书使用的包装函数均定义在 <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/ics2/code/include/csapp.h"><code>csapp.h</code></a> 和 <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/ics2/code/src/csapp.c"><code>csapp.c</code></a> 中。</p>
<h1 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4.进程控制"></a>4.进程控制</h1><h2 id="4-1-获取进程ID"><a href="#4-1-获取进程ID" class="headerlink" title="4.1 获取进程ID"></a>4.1 获取进程ID</h2><p>​	每个进程都有一个唯一且大于 0 的进程 ID（PID）。函数<code>getpid</code>返回调用进程的 PID，而函数<code>getppid</code>则返回创建调用进程的进程（即父进程） 的 PID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>二者返回值的类型均为<code>pid_t</code>，它在 Linux 系统的<code>sys/types.h</code>文件中被定义为<code>int</code>。</p>
<h2 id="4-2-创建和终止进程"><a href="#4-2-创建和终止进程" class="headerlink" title="4.2 创建和终止进程"></a>4.2 创建和终止进程</h2><p>在程序员看来，进程有三种状态：</p>
<ul>
<li>运行（Running）：该进程要么在 CPU 中执行，要么在等待内核调度；</li>
<li>停止（Stopped）：进程的执行被挂起(suspend)，且不会被调度。当收到SIGSTOP、SIGTSTPSIDTTIN 或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。(信号是一种软件中断的形式，将在5节中详细描述。)</li>
<li>终止（Terminated）：进程永远地停止了。进程会因为三种原因终止:1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用exit函数。</li>
</ul>
<p>函数<code>exit</code>会以参数<code>status</code>作为退出状态终止进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br></code></pre></td></tr></table></figure>



<p>父进程可以调用<code>fork</code>函数来创建一个新的子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>​	子进程将获得一个与父进程相同但独立的用户级虚拟内存空间副本，包括代码、数据、堆、共享库和用户栈等。它还会得到与父进程相同的打开文件描述符副本，因此能够读写任意父进程打开的文件。父进程和子进程之间最显著的区别便是 <strong>PID</strong> 不同。</p>
<p>​	函数<code>fork</code><strong>执行一次却返回两次</strong>：在父进程中返回子进程的 PID，在子进程中返回 0。由于子进程的 PID 始终大于 0 ，我们可以通过返回值判断程序在哪个进程中执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">include <span class="hljs-string">&quot;csapp.h&quot;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><br>    pid = Fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">/* Child */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child : x=%d\n&quot;</span>, ++x);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Parent */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: x=%d\n&quot;</span>, --x);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该程序编译后运行的可能结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">./fork</span><br>parent: x=0<br>child : x=2<br></code></pre></td></tr></table></figure>



<p>从结果我们可以看出：</p>
<ul>
<li>调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的。但是具有多个 fork实例的程序可能就会令人迷惑，需要仔细地推敲了。</li>
<li>并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</li>
<li>相同的但是独立的地址空间。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对x<br>所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</li>
<li>共享文件当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏<br>幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时，stdout文<br>件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</li>
</ul>
<p>绘制进程图（Process Graph）对理解<code>fork</code>函数很有帮助，如：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/cbc3c80a45df3ecad9fdece41e741bdf.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="4-3-回收子进程"><a href="#4-3-回收子进程" class="headerlink" title="4.3 回收子进程"></a>4.3 回收子进程</h2><p>进程终止后，内核不会立即将其移除。它需要被其父进程回收（Reap），否则将成为僵尸（Zombie）进程。当父进程回收其终止的子进程时，内核将子进程的退出状态传递给父进程，然后再丢弃它。</p>
<p>如果父进程终止，内核会安排<code>init</code>进程（PID 为 1）“收养”孤儿进程；如果父进程在终止前没有回收僵尸子进程，那么则由<code>init</code>进程回收它们。</p>
<p>进程通过调用函数<code>waitpid</code>等待其子进程终止或停止：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *statusp, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">// Returns: PID of child if OK, 0 (if WNOHANG), or −1 on error</span><br></code></pre></td></tr></table></figure>



<p>默认情况下（参数<code>options</code>为 0 时），函数<code>waitpid</code>会暂停调用进程，直至其等待集（Wait Set）中的某个子进程终止。该函数始终返回第一个终止的子进程 PID。此时，终止的子进程已被回收，内核从系统中删除了它的所有痕迹。</p>
<ol>
<li><p><strong>判定等待集合的成员</strong></p>
<p>等待集合的成员是由参数pid 来确定的:</p>
<ul>
<li>如果 pid&gt;0，那么等待集合就是一个单独的子进程，它的进程 等于 pid。</li>
<li>如果 pid&#x3D;-1，那么等待集合就是由父进程所有的子进程组成的。</li>
</ul>
<p>waitpid 函数还支持其他类型的等待集合，包括 Unix 进程组，对此我们将不做讨论。</p>
</li>
<li><p><strong>修改默认行为</strong></p>
<p>我们可以通过修改参数<code>options</code>的值来改变函数<code>waitpid</code>的行为：</p>
<ul>
<li><code>WNOHANG</code>：如果等待集中的子进程还未终止，则立即返回 0；</li>
<li><code>WUNTRACED</code>：暂停调用进程执行，直到等待集中的进程终止或停止（默认情况下仅返回终止的子进程 PID）；</li>
<li><code>WCONTINUED</code>：暂停调用进程执行，直到等待集中的进程终止或等待集中停止的进程收到 SIGCONT 信号恢复。</li>
</ul>
</li>
<li><p><strong>检查已回收子进程退出状态</strong></p>
<p>若参数<code>statusp</code>不为<code>NULL</code>，那么<code>waitpid</code>还会将返回的子进程状态信息编码到<code>status</code>中（<code>*statusp = status</code>）。<code>wait.h</code>文件定义了几个用于解释参数<code>status</code>的宏：</p>
<ul>
<li><code>WIFEXITED(status)</code>：如果子进程正常终止（比如调用<code>exit</code>或返回），则返回<code>True</code>；</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED()</code>返回<code>True</code>，则返回终止子进程的退出状态；</li>
<li><code>WIFSIGNALED(status)</code>：如果子进程由于未捕获的信号而终止，则返回<code>True</code>；</li>
<li><code>WTERMSIG(status)</code>：如果<code>WIFSIGNALED()</code>返回<code>True</code>，则返回导致子进程终止的信号编号；</li>
<li><code>WIFSTOPPED(status)</code>：如果返回的子进程当前已停止，则返回<code>True</code>；</li>
<li><code>WSTOPSIG(status)</code>：如果<code>WIFSTOPPED()</code>返回<code>True</code>，则返回导致子进程停止的信号编号；</li>
<li><code>WIFCONTINUED(status)</code>：如果子进程收到 SIGCONT 信号后恢复，则返回<code>True</code>。</li>
</ul>
</li>
<li><p><strong>错误条件</strong></p>
<p>如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid 函数被一个信号中断，那么它返回-1，并设置errno为EINTR。</p>
</li>
</ol>
<p>函数<code>wait</code>是<code>waitpid</code>的简化版本，<code>wait(&amp;status)</code>等效于<code>waitpid(-1, &amp;status, 0)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> status, i;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">/* Parent creates N children */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">if</span> ((pid = Fork()) == <span class="hljs-number">0</span>) <span class="hljs-comment">/* child */</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">100</span> + i);<br><br>    <span class="hljs-comment">/* Parent reaps N children in no particular order */</span><br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, <span class="hljs-number">0</span>)) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, pid, WEXITSTATUS(status));<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated abnormally\n&quot;</span>, pid);<br>    &#125;<br><br>    <span class="hljs-comment">/* The only normal termination is if there are no more children */</span><br>    <span class="hljs-keyword">if</span> (errno != ECHILD)<br>        unix_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>如示例程序所示，父进程首先调用<code>Fork</code>创建了两个退出状态唯一的子进程（<code>exit(100+i)</code>）。 随后在 While 循环的测试条件中通过<code>waitpid</code>等待其所有的子进程终止，并打印子进程的退出状态。最终所有的子进程均被回收，<code>waitpid</code>返回 -1 且将全局变量<code>errno</code>设为<code>ECHILD</code>，函数执行完毕。</p>
<p>在 Linux 系统上运行该程序时，它会产生以下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">./waitpid1</span><br>child 22966 terminated normally with exit status=100 <br>child 22967 terminated normally with exit status=101<br></code></pre></td></tr></table></figure>

<p>值得注意的是，父进程回收子进程的顺序是随机的。我们可以对上述程序进行一定 <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/ics2/code/ecf/waitpid2.c">修改</a>，从而使其按子进程的 PID 顺序输出。</p>
<h2 id="4-4-休眠"><a href="#4-4-休眠" class="headerlink" title="4.4 休眠"></a>4.4 休眠</h2><p>​	</p>
<p>函数<code>sleep</code>可以让进程暂停执行一段时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;<br><span class="hljs-comment">// Returns: seconds left to sleep</span><br></code></pre></td></tr></table></figure>

<p>如果请求的暂停时间已经过去，则函数返回 0；如果该进程被信号中断，则返回剩余的暂停时间。</p>
<p>函数<code>pause</code>会使调用进程进入休眠状态，直至收到信号。该函数始终返回 -1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>



<h2 id="4-5-加载并运行程序"><a href="#4-5-加载并运行程序" class="headerlink" title="4.5 加载并运行程序"></a>4.5 加载并运行程序</h2><p>函数<code>execve</code>在当前进程的上下文中加载并运行一个新程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[], <span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span>;<br></code></pre></td></tr></table></figure>

<p>参数<code>filename</code>是加载并运行的可执行文件名称，<code>argv</code>和<code>envp</code>则分别是参数和环境变量列表。函数<code>execve</code>通常没有返回值，仅在出现错误时返回 -1。</p>
<p>变量<code>argv</code>指向一个以<code>NULL</code>为结尾的指针数组，其中的每个元素都指向一个参数字符串。一般来说，<code>argv[0]</code>是可执行目标文件名称；变量<code>envp</code>也指向一个以<code>NULL</code>结尾的指针数组，其中的每个元素均指向一个环境变量字符串，每个字符串都是一个<code>name=value</code>形式的键值对。两者的数据结构如下：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/ae914cfeb058062b268d69da354c80f3.png" srcset="/img/loading.gif" lazyload></p>
<p><code>execve</code>加载文件名后，会调用启动代码。 启动代码设置栈并将控制权传递给新程序的<code>main</code>函数，其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span>;<br></code></pre></td></tr></table></figure>

<p><code>main</code>函数执行时的用户栈结构如下图所示，从栈底到栈顶分别是：环境变量字符串、参数字符串、指向环境变量字符串的指针数组和指向参数字符串的指针数组。该函数的三个参数分别保存在不同的寄存器中：参数<code>argc</code>给出数组<code>argv[]</code>中的非空指针数量；参数<code>argv</code>指向数组<code>argv[]</code>中第一个元素；参数<code>envp</code>则指向数组<code>envp[]</code>中的第一个元素：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/97c29ce1fd15a29770b5c8bef051ec30.png" srcset="/img/loading.gif" lazyload></p>
<p>Linux 提供了几个用于操作环境变量数组的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newvalue, <span class="hljs-type">int</span> overwrite)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unsetenv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure>

<p>如果数组中包含以参数<code>name</code>为键的字符串，则函数<code>getenv</code>返回其对应的值，函数<code>unsetenv</code>删除该字符串，函数<code>setenv</code>将值替换为参数<code>newvalue</code>（<code>overwrite</code>非零时）；如果不存在以<code>name</code>为键的字符串，则函数<code>setenv</code>会将<code>name=newvalue</code>添加到数组中。</p>
<div class="note note-secondary">
            <p>​	<strong>程序与进程</strong></p><p>​	这是一个适当的地方，停下来，确认一下你理解了程序和进程之间的区别。程序是一堆代码和数据;程序可以作为目标模块存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实例;程序总是运行在某个进程的上下文中。如果你想要理解 fork和execve函数，理解这个差异是很重要的。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve 函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用<br>execve 函数时已打开的所有文件描述符。</p>
          </div>



<h2 id="4-6-使用fork和execve运行程序"><a href="#4-6-使用fork和execve运行程序" class="headerlink" title="4.6 使用fork和execve运行程序"></a>4.6 使用fork和execve运行程序</h2><p>​	Unix shell 和 Web 服务器等程序大量使用了<code>fork</code>和<code>execve</code>函数。外壳是一个交互型的应用级程序，它代表用户运行其他程序。最早的外壳是sh程序，后面出现了些变种，比如 csh、tcsh、ksh和bash。外壳执行一系列的读&#x2F;求值(read&#x2F;evaluate)步骤然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。本书提供了一个简单的 <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/ics2/code/ecf/shellex.c">shell 程序</a>，其缺陷在于没有回收任何后台运行的子进程。我们需要使用下一节介绍的信号来解决这一问题。</p>
<h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5.信号"></a>5.信号</h1><p>​	信号（Signal）是一种高级的异常控制流，它允许进程和内核将某些类型的系统事件通知给其他进程。</p>
<p>​	一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux 系统上支持的 30种不同类型的信号。在外壳命令行上输入“man 7 signal”就能得到这个列表。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/7a833933ce9bfcbdef02aa0e1776a7b5.png" srcset="/img/loading.gif" lazyload></p>
<p>​	低级别的硬件异常由内核中的异常处理程序处理，通常不会对用户进程可见，而信号则可以将此类异常暴露给用户进程。如果一个进程试图除以 0，内核就会向它发送一个 SIGFPE（编号 8）信号。</p>
<h2 id="5-1-信号术语"><a href="#5-1-信号术语" class="headerlink" title="5.1 信号术语"></a>5.1 信号术语</h2><p>发送信号到目标进程需要完成两个步骤：</p>
<ul>
<li>发送（传递）信号：内核通过更新目标进程上下文中的某些状态来向目标进程发送信号。发送信号的原因有两种：① 内核检测到系统事件的发生，如被 0 除错误或子进程终止等；② 进程调用了<code>kill</code>函数（将在下一节介绍）。进程可以向自己发送信号；</li>
<li>接收信号：当内核强制目标进程以某种方式对信号做出响应时，它便接收到了信号。该进程可以通过执行用户级别的信号处理程序（Signal Handler）来忽略、终止或捕获信号。</li>
</ul>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/df7c97d463c49fa506c323610ab7b4c2.png" srcset="/img/loading.gif" lazyload></p>
<p>​	已发送但还未接收的信号被称为<strong>待处理信号（Pending Signal）</strong>。在任意时间点，相同类型的待处理信号最多只能有一个。这意味着如果一个进程已经有一个类型为 k 的待处理信号，那么后续所有发送给该进程的 k 类型信号都将被丢弃。进程还可以选择性地<strong>阻塞（Block）</strong>某些信号的接收。</p>
<h2 id="5-2-发送信号"><a href="#5-2-发送信号" class="headerlink" title="5.2 发送信号"></a>5.2 发送信号</h2><p>​	Linux系统提供了大量向进程发送信号的机制。所有这些机制都是基于**进程组(process group)**这个概念的。</p>
<h3 id="1-进程组"><a href="#1-进程组" class="headerlink" title="1. 进程组"></a>1. <strong>进程组</strong></h3><p>​	每个进程都属于一个进程组（Process Group），它由一个正整数的进程组 ID 所标识。<code>getpgrp</code>函数返回当前进程的进程组 ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgrp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>默认情况下，子进程与其父进程属于同一个进程组。进程可以通过<code>setpgid</code>函数改变自己或另一个进程的进程组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;<br></code></pre></td></tr></table></figure>

<p>该函数会把进程<code>pid</code>的进程组更改为<code>pgid</code>。若将参数<code>pid</code>或<code>pgid</code>设为 0，则相当于使用调用进程的 PID 作为参数。举例来说，如果进程 15213 调用函数<code>setpgid(0, 0)</code>，那么将会创建一个进程组 ID 为 15213 的新进程组，并使该进程加入此组。</p>
<h3 id="2-用-bin-kill-程序发送信号"><a href="#2-用-bin-kill-程序发送信号" class="headerlink" title="2. 用 &#x2F;bin&#x2F;kill 程序发送信号"></a>2. <strong>用 &#x2F;bin&#x2F;kill 程序发送信号</strong></h3><p>​	&#x2F;bin&#x2F;kill 程序可以可以向另外的进程发送任意的信号。比如，命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt;</span><span class="language-bash">/bin/kill -9 15213</span><br></code></pre></td></tr></table></figure>


<p>发送信号9(SIGKILL)给进程15213。一个为负的PID会导致信号被发送到进程组PID中的每个进程。比如，命令:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unix</span>&gt;/bin/kill -<span class="hljs-number">9</span> -<span class="hljs-number">15213</span><br></code></pre></td></tr></table></figure>

<p>发送一个SIGKIL信号给进程组15213中的每个进程。注意，在此我们使用完整路径&#x2F;bin&#x2F;kill，因为有些 Linux 外壳有自己内置的 kill 命令。</p>
<h3 id="3-用键盘发送信号"><a href="#3-用键盘发送信号" class="headerlink" title="3. 用键盘发送信号"></a>3. <strong>用键盘发送信号</strong></h3><p>​	Unix Shell 使用<strong>任务（Job）</strong>表示单个命令行（如<code>ls | sort</code>）创建的进程，同一时间内只能有一个前台任务和多个后台任务。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/30afcac9e0147e4dcf6227e8fa9f4c73.png" srcset="/img/loading.gif" lazyload></p>
<p>在键盘上输入 Ctrl+C 会使内核向前台进程组中的所有进程发送 SIGINT 信号，这将终止前台任务。同样，输入 Ctrl+Z 会使内核向前台进程组中的所有进程发送 SIGTSTP 信号，这将停止（挂起）前台任务。</p>
<h3 id="4-用kill函数发送信号"><a href="#4-用kill函数发送信号" class="headerlink" title="4. 用kill函数发送信号"></a>4. 用kill函数发送信号</h3><p>​	进程可以调用<code>kill</code>函数向其他进程（包括其自身）发送信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure>

<p>若参数<code>pid</code>大于 0，则该函数将编号为<code>sig</code>的信号发送给进程<code>pid</code>；若参数<code>pid</code>等于 0，则该函数将信号发送给调用进程所在进程组中的所有进程；如果参数<code>pid</code>小于 0，则该函数将信号发送给进程组 ID 为<code>|pid|</code>的进程组中的所有进程。</p>
<h3 id="5-使用-alarm-函数发送信号"><a href="#5-使用-alarm-函数发送信号" class="headerlink" title="5. 使用 alarm 函数发送信号"></a>5. 使用 alarm 函数发送信号</h3><p>​	进程可以调用<code>alarm</code>函数向自己发送 SIGALRM 信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;<br><span class="hljs-comment">// Returns: remaining seconds of previous alarm, or 0 if no previous alarm</span><br></code></pre></td></tr></table></figure>

<p>内核将在<code>secs</code>秒后向调用进程发送 SIGALRM 信号，取消所有之前设置的<code>alarm</code>，并返回其剩余的秒数。</p>
<h2 id="5-3-接收信号"><a href="#5-3-接收信号" class="headerlink" title="5.3 接收信号"></a>5.3 接收信号</h2><p>当内核将进程 p 从内核态切换到用户态时，它会检查 p <strong>未阻塞且未处理（Pending &amp; ~Blocked）</strong>的信号集。通常该集合为空，内核将控制权转移给 p 的逻辑控制流中的下一条指令。但如果该集合非空，内核就会选择信号集中的某个信号 k 并强制 p 接收它。信号将触发进程完成一些<strong>动作（Action）</strong>，预定义的默认动作有：</p>
<ul>
<li>进程终止；</li>
<li>进程终止并转储核心（Dump Core，即将代码和数据内存段的镜像写入磁盘）；</li>
<li>进程停止（暂停），直到接收 SIGCONT 信号重新启动；</li>
<li>进程忽略该信号。</li>
</ul>
<p>每种信号的默认动作见 <a href="#5.%E4%BF%A1%E5%8F%B7">图 8.25</a>。除 SIGSTOP 和 SIGKILL 信号外，进程还可以通过函数<code>signal</code>修改信号的默认动作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-comment">// Returns: pointer to previous handler if OK, SIG_ERR on error (does not set errno)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>若参数<code>handler</code>为<code>SIG_IGN</code>，则<code>signum</code>类型的信号将会被忽略；</li>
<li>若参数<code>handler</code>为<code>SIG_DFL</code>，则<code>signum</code>类型的信号的动作将恢复为默认；</li>
<li>若参数<code>handler</code>为<strong>用户定义的信号处理程序地址</strong>，则进程接收到<code>signum</code>类型的信号后会调用该程序，这种方法被称为安装处理程序（Installing Handler）。在这种情况下，调用处理程序被称为捕获信号（Catching Signal），执行处理程序被称为<strong>处理信号（Handling Signal）</strong>。</li>
</ul>
<p>如果我们在示例程序运行时按下 Ctrl+C，该进程就不会直接终止而是输出一段信息后才终止：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> <span class="hljs-comment">/* SIGINT handler */</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Caught SIGINT\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* Install the SIGINT handler */</span><br>    <span class="hljs-keyword">if</span> (signal(SIGINT, handler) == SIG_ERR)<br>        unix_error(<span class="hljs-string">&quot;signal error&quot;</span>);<br><br>    Pause(); <span class="hljs-comment">/* Wait for the receipt of a signal */</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>信号处理程序还可以被其他处理程序中断（信号 <em>s≠t</em>）：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/%E5%88%B6%E6%B5%81/20220223154049.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5-4-阻塞信号"><a href="#5-4-阻塞信号" class="headerlink" title="5.4 阻塞信号"></a>5.4 阻塞信号</h2><p>Linux 为阻塞信号提供了显式和隐式的实现机制：</p>
<ul>
<li>隐式：默认情况下，内核会阻塞任何与处理程序当前正在处理的信号类型相同的未处理信号。比如上图 8.31 中，若信号 <em>t</em> 的类型与 <em>s</em> 相同，则 <em>t</em> 将在处理程序 <em>S</em> 返回前持续挂起；</li>
<li>显式：应用程序可以调用<code>sigprocmask</code>等函数阻塞信号或解除信号的阻塞。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">// Returns: 1 if member, 0 if not, −1 on error</span><br></code></pre></td></tr></table></figure>

<p><code>sigprocmask</code>函数可以改变当前阻塞信号的集合（设为<code>blocked</code>），具体行为取决于参数<code>how</code>的值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将参数<code>set</code>中的信号阻塞（<code>blocked = blocked | set</code>）；</li>
<li><code>SIG_UNBLOCK</code>：为<code>set</code>中的信号解除阻塞（<code>blocked = blocked &amp; ~set</code>）；</li>
<li><code>SIG_SETMASK</code>：将阻塞信号集合设为<code>set</code>（<code>blocked = set</code>）。</li>
</ul>
<p>如果参数<code>oldset</code>非空，则先前<code>blocked</code>的值会存储在<code>oldset</code>中。</p>
<p>除此之外，函数<code>sigemptyset</code>将<code>set</code>初始化为空集；<code>sigfillset</code>将所有信号加入到<code>set</code>中；<code>sigaddset</code>将编号为<code>signum</code>的信号加入到<code>set</code>中；<code>sigdelset</code>将编号为<code>signum</code>的信号从<code>set</code>中删除；如果<code>signum</code>信号在<code>set</code>中，则函数<code>sigismember</code>返回 1，否则返回 0。</p>
<p>示例程序暂时阻塞了 SIGINT 信号的接收：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sigset_t</span> mask, prev_mask;<br>sigemptyset(&amp;mask);<br>sigaddset(&amp;mask, SIGINT);<br><span class="hljs-comment">/* Block SIGINT and save previous blocked set */</span><br>sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);<br><br><span class="hljs-comment">// Code region that will not be interrupted by SIGINT</span><br><br><span class="hljs-comment">/* Restore previous blocked set, unblocking SIGINT */</span><br>sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>



<h2 id="5-5-编写信号处理程序"><a href="#5-5-编写信号处理程序" class="headerlink" title="5.5 编写信号处理程序"></a>5.5 编写信号处理程序</h2><p>​	</p>
<h3 id="1-安全的信号处理"><a href="#1-安全的信号处理" class="headerlink" title="1. 安全的信号处理"></a>1. 安全的信号处理</h3><p>​	如果处理程序和主程序并发地访问同一个全局数据结构，就会发生不可预知的严重问题。因此我们在编写信号处理程序时应当遵循以下守则：</p>
<ul>
<li>使信号处理程序尽可能的简单；</li>
<li>仅调用异步信号安全（Async-Signal-Safe）的函数。这种函数一般只访问局部变量，或者不会被其他信号处理程序中断。值得注意的是，许多常用的函数，如<code>printf</code>、<code>sprintf</code>、<code>malloc</code>和<code>exit</code>等并非异步信号安全。调用<code>write</code>函数是信号处理程序生成输出的唯一安全方法；</li>
<li>保存并恢复变量<code>errno</code>：许多 Linux 异步信号安全函数返回错误时会设置变量<code>errno</code>的值，因此可能会干扰程序中其他依赖<code>errno</code>的部分。当处理程序有返回时，我们应当在调用前将<code>errno</code>保存到局部变量中，并在返回前恢复其值；</li>
<li>访问全局数据结构时阻塞所有信号；</li>
<li>假设主程序和信号处理程序共享全局变量<code>g</code>，处理程序更新<code>g</code>的值，主程序定期读取<code>g</code>的值。优化的编译器会从寄存器中读取已缓存的<code>g</code>，因此主函数中的<code>g</code>可能永远不变，并且每次对<code>g</code>的引用也都是安全的。若使用<code>volatile</code>声明全局变量，如<code>volatile int g;</code>，那么当代码引用<code>g</code>时，编译器就会从内存中读取其值。在这种情况下，我们应当临时阻塞信号以保护对<code>g</code>的访问；</li>
<li>在常见的设计中，处理程序通过写入全局标识（Flag）来记录信号的接收。若使用<code>sig_atomic_t</code>类型声明标识，如<code>volatile sig_atomic_t flag;</code>，那么便可以保证<code>flag</code>写入的原子性（Atomic&#x2F;Uninterruptible）。</li>
</ul>
<h3 id="2-正确的信号处理"><a href="#2-正确的信号处理" class="headerlink" title="2. 正确的信号处理"></a>2. 正确的信号处理</h3><p>​	上文提到，父进程必须回收子进程以避免在系统中留下僵尸进程，但我们也希望父进程可以在子进程运行时自由地执行其他任务。因此我们使用 SIGCHILD 处理程序来回收子进程，而不是显式地调用<code>waitpid</code>等待子进程终止：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler1</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span> ((pid = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Handler reaped child %d\n&quot;</span>, (<span class="hljs-type">int</span>)pid);<br>    Sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, n;<br>    <span class="hljs-type">char</span> buf[MAXBUF];<br><br>    <span class="hljs-keyword">if</span> (signal(SIGCHLD, handler1) == SIG_ERR)<br>        unix_error(<span class="hljs-string">&quot;signal error&quot;</span>);<br><br>    <span class="hljs-comment">/* Parent creates children */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-string">&quot;Hello from child %d\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());<br>            Sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Parent waits for terminal input and then processes it */</span><br>    <span class="hljs-keyword">if</span> ((n = read(STDIN_FILENO, buf, <span class="hljs-keyword">sizeof</span>(buf))) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;read&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent processing input\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        ;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例程序中，父进程安装了处理程序<code>handler1</code>并创建三个子进程。它等待来自终端的输入，然后进入 While 循环。每当一个子进程终止时，内核将发送一个 SIGCHLD 信号通知父进程。父进程捕获信号后回收子进程，输出一段信息然后返回。</p>
<p>​	在 Linux 上运行该程序得到的输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">linux&gt; ./signal1<br>Hello from child <span class="hljs-number">14073</span> <br>Hello from child <span class="hljs-number">14074</span> <br>Hello from child <span class="hljs-number">14075</span> <br>Handler reaped child <br>Handler reaped child<br>CR<br>Parent processing input<br></code></pre></td></tr></table></figure>



<p>​	父进程创建了三个子进程，然而却只回收了两个，这是因为同一时间内相同类型的未处理信号最多只能有一个。信号处理程序在处理第一个信号时，第二个信号到达并被添加到未处理信号集中。由于已有一个未处理的 SIGCHLD 信号，此时若第三个信号到达便会被直接丢弃。当处理程序返回后，内核发现第二个信号还未处理，于是强制父进程接收该信号并重新执行处理程序。等到处理程序再次返回，父进程就不再有任何未处理的 SIGCHLD 信号了。</p>
<p>我们可以让处理程序在被调用时尽可能多地回收子进程以解决这一问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">handler2</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG)) &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Handler reaped child %d\n&quot;</span>, (<span class="hljs-type">int</span>)pid);<br>    <span class="hljs-keyword">if</span> (errno != ECHILD)<br>        unix_error(<span class="hljs-string">&quot;waitpid error&quot;</span>);<br>    Sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-可移植的信号处理"><a href="#3-可移植的信号处理" class="headerlink" title="3. 可移植的信号处理"></a>3. 可移植的信号处理</h3><p>​	不同的系统有着不同的信号处理语义，因此 Posix 标准定义了<code>sigaction</code>函数，它允许用户在安装信号处理程序时明确地指定他们想要的语义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,  <span class="hljs-keyword">struct</span> sigaction *act,</span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure>

<p>然而<code>sigaction</code>函数十分笨重，因此我们常使用它的包装函数<code>Signal</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">handler_t</span> *<span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">handler_t</span> *handler)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br>    action.sa_handler = handler;<br>    sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* Block sigs of type being handled */</span><br>    action.sa_flags = SA_RESTART; <span class="hljs-comment">/* Restart syscalls if possible */</span><br><br>    <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>    <span class="hljs-keyword">return</span> (old_action.sa_handler);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-6-避免并发错误"><a href="#5-6-避免并发错误" class="headerlink" title="5.6 避免并发错误"></a>5.6 避免并发错误</h2><p>​	上文提到，我们永远无法预测两个同步（并发）运行的函数的调用顺序。如果调用顺序会影响结果的正确性，那么这种错误就被称为竞争（Race）。我们可以通过阻塞相关信号来避免这一问题。</p>
<h2 id="5-7-显式等待信号"><a href="#5-7-显式等待信号" class="headerlink" title="5.7 显式等待信号"></a>5.7 显式等待信号</h2><p>​	有时候主程序需要显式等待某个信号处理程序运行完毕。例如 Linux Shell 创建前台任务后，必须等待任务终止并被 SIGCHLD 处理程序回收，然后才能接收下一条用户命令。示例程序展示了其基本思想：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">sig_atomic_t</span> pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>    <span class="hljs-type">int</span> olderrno = errno;<br>    pid = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    errno = olderrno;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>&#123;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">sigset_t</span> mask, prev;<br>    Signal(SIGCHLD, sigchld_handler);<br>    Signal(SIGINT, sigint_handler);<br>    Sigemptyset(&amp;mask);<br>    Sigaddset(&amp;mask, SIGCHLD);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="hljs-comment">/* Block SIGCHLD */</span><br>        <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>)                      <span class="hljs-comment">/* Child */</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">/* Parent */</span><br>        pid = <span class="hljs-number">0</span>;<br>        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Unblock SIGCHLD */</span><br>        <span class="hljs-comment">/* Wait for SIGCHLD to be received (wasteful) */</span><br>        <span class="hljs-keyword">while</span> (!pid)<br>            ;<br>        <span class="hljs-comment">/* Do some work after receiving SIGCHLD */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	父进程先为信号 SIGCHLD 和 SIGINT 安装处理程序，然后创建子进程并将全局变量<code>pid</code>设为 0，最后进入自旋循环（<code>while (!pid)</code>）。子进程终止后，<code>pid</code>变为非 0，于是父进程退出自旋循环。为了防止父进程进入自旋循环前接收到 SIGCHLD ，我们需要在创建子进程之前阻塞该信号。</p>
<p>这段代码是正确的，但自旋循环会浪费处理器资源。我们可以将其改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!pid) <span class="hljs-comment">/* Race! */</span><br>    pause();<br></code></pre></td></tr></table></figure>

<p>问题在于：如果父进程在 While 的条件测试之后而<code>pause</code>的执行之前接收到 SIGCHLD，那么程序就会永远休眠。我们还可以将<code>pause</code>改为<code>sleep</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!pid) <span class="hljs-comment">/* Too slow! */</span><br>    sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>这样虽然避免了竞争问题，但会增加程序的运行时间。正确的解决方案是调用函数<code>sigsuspend</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsuspend</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *mask)</span>;<br><span class="hljs-comment">// Returns: -1</span><br></code></pre></td></tr></table></figure>

<p>该函数使用参数<code>mask</code>替换当前的阻塞信号集合，然后暂停进程直至其接收信号。如果该信号的动作是终止进程，则进程终止且不从<code>sigsuspend</code>返回；如果该信号的动作是运行一个处理程序，则<code>sigsuspend</code>在处理程序返回后返回，并将阻塞信号集合的状态恢复。</p>
<p>实际上它等效于下列函数组合的原子性（Atomic，即不可中断）版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);<br>pause();<br>sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p>因此我们可以将示例函数修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="hljs-comment">/* Block SIGCHLD */</span><br>    <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>)                      <span class="hljs-comment">/* Child */</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/* Wait for SIGCHLD to be received */</span><br>    pid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pid)<br>        sigsuspend(&amp;prev);<br>    <span class="hljs-comment">/* Optionally unblock SIGCHLD */</span><br>    Sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/* Do some work after receiving SIGCHLD */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="6-非本地跳转"><a href="#6-非本地跳转" class="headerlink" title="6. 非本地跳转"></a>6. 非本地跳转</h1><p>​	C 提供了一种用户级别的异常控制流，即<strong>非本地跳转（Nonlocal Jump）</strong>。它无需完成正常的调用&#x2F;返回序列，就可以将控制权从一个函数直接转移到另一个当前正在执行的函数。非本地跳转是通过<code>setjmp</code>和<code>longjmp</code>函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> savesigs)</span>;<br><span class="hljs-comment">// Returns: 0 from setjmp, nonzero from longjmps</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_buf env, <span class="hljs-type">int</span> retval)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">siglongjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> retval)</span>;<br><span class="hljs-comment">// Never returns</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>setjmp</code>函数将当前调用环境（Calling Environment，包括程序计数器、栈指针和通用寄存器等），保存在参数<code>env</code>指定的缓冲区中并返回 0。</li>
<li><code>longjmp</code>函数会从<code>env</code>缓冲区恢复调用环境，然后触发最近调用的<code>setjmp</code>函数的返回。这种情况下，<code>setjmp</code>会返回一个非零值<code>retval</code>。</li>
<li>在信号处理程序中，我们使用<code>sigsetjmp</code>和<code>siglongjmp</code>代替它们。</li>
</ul>
<p>非局部跳转的一个重要应用是可以在检测到某些错误条件时，从深度嵌套的函数调用中立即返回。我们使用非本地跳转直接返回到常见的错误处理程序，无需费力地<strong>展开栈（Unwind Stack）</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><br>jmp_buf buf;<br><br><span class="hljs-type">int</span> error1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> error2 = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>, <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (setjmp(buf))<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        foo();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error1 condition in foo\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error2 condition in foo\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown error condition in foo\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* Deeply nested function foo */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (error1)<br>        longjmp(buf, <span class="hljs-number">1</span>);<br>    bar();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (error2)<br>        longjmp(buf, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例程序中主函数首先调用<code>setjmp</code>保存当前调用环境，然后依次调用函数<code>foo</code>和<code>bar</code>。 一旦函数执行发生错误，它们会立即通过<code>longjmp</code>从<code>setjmp</code>返回。<code>setjmp</code>的非零返回值表示错误的类型，因此我们可以在代码中的某处对其进行处理。</p>
<p>非局部跳转的另一个重要应用是从信号处理程序跳转到特定代码位置，而不是像往常那样返回到因信号中断的指令。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="print-no-link">#阅读笔记</a>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP_阅读笔记_8_异常控制流</div>
      <div>http://example.com/2024/08/30/CSAPP-阅读笔记-8-异常控制流/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>7qing</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月30日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年8月31日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/08/31/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="CSAPP_阅读笔记_9_虚拟内存">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSAPP_阅读笔记_9_虚拟内存</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/28/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-7-%E9%93%BE%E6%8E%A5/" title="CSAPP_阅读笔记_7_链接">
                        <span class="hidden-mobile">CSAPP_阅读笔记_7_链接</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","appKey":"IdTuwk7eTRDfLgZzPUknFG0z","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
