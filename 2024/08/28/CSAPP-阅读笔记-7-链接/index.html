

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="7qing">
  <meta name="keywords" content="">
  
    <meta name="description" content="​	 链接(linking) 是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可**被加载(或被拷贝)到存储器并执行。链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时;也可以执行于加载时(loadtime)，也就是在程序被加载器(loader)加载到存储器并执行时;甚至执行于运行时(run time)，由应用程序来执行。在早期的计算机系统中，链">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP_阅读笔记_7_链接">
<meta property="og:url" content="http://example.com/2024/08/28/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-7-%E9%93%BE%E6%8E%A5/index.html">
<meta property="og:site_name" content="7qing">
<meta property="og:description" content="​	 链接(linking) 是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可**被加载(或被拷贝)到存储器并执行。链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时;也可以执行于加载时(loadtime)，也就是在程序被加载器(loader)加载到存储器并执行时;甚至执行于运行时(run time)，由应用程序来执行。在早期的计算机系统中，链">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/7qing.png">
<meta property="article:published_time" content="2024-08-28T12:07:45.000Z">
<meta property="article:modified_time" content="2024-08-29T17:14:25.814Z">
<meta property="article:author" content="7qing">
<meta property="article:tag" content="阅读笔记">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/7qing.png">
  
  
  
  <title>CSAPP_阅读笔记_7_链接 - 7qing</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","app_key":"IdTuwk7eTRDfLgZzPUknFG0z","server_url":"https://j6zz0vra.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>7qing</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/backward.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP_阅读笔记_7_链接"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-28 20:07" pubdate>
          2024年8月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          80 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSAPP_阅读笔记_7_链接</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2024-08-30T01:14:25+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>​	 <strong>链接(linking)</strong> 是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可**被加载(或被拷贝)<strong>到存储器并执行。链接可以执行于</strong>编译时(compile time)<strong>，也就是在源代码被翻译成机器代码时;也可以执行于</strong>加载时(loadtime)<strong>，也就是在程序被</strong>加载器(loader)<strong>加载到存储器并执行时;甚至执行于</strong>运行时(run time)<strong>，由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做</strong>链接器(linker)<strong>的程序自动执行的。<br>​	链接器在软件开发中扮演着一个关键的角色，因为它们使得</strong>分离编译(separate compilation)**成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<h1 id="1-编译器驱动程序"><a href="#1-编译器驱动程序" class="headerlink" title="1.编译器驱动程序"></a>1.编译器驱动程序</h1><p>​	大多数编译系统都提供了一个<strong>编译器驱动（Compiler Driver）</strong>，它可以根据用户需求调用<strong>语言预处理器（Language Preprocessor）</strong>、编译器、汇编器和链接器等。例如要在 GNU 编译系统中构建下列程序，我们可以 使用命令：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -<span class="hljs-number">02</span> -<span class="hljs-selector-tag">g</span> -o <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> swap.c<br></code></pre></td></tr></table></figure>

<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/c5dbec50679efcb44fdf4986480d2b7d.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/8686ddb2b4177e202d5493a7cdd4a93c.png" srcset="/img/loading.gif" lazyload></p>
<p>​	上图概括了驱动程序在将示例程序从ASCI码源文件翻译成可执行目标文件时的行为。(如果你想看看这些步骤，用-v选项来运行GCC)</p>
<p>驱动程序首先运行C预处理器(cpp)，它将C源程序 main.c翻译成一个 <strong>ASCII码的中间文件</strong> main.i.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cpp <span class="hljs-selector-attr">[other arguments]</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> /tmp/<span class="hljs-selector-tag">main</span>.i<br></code></pre></td></tr></table></figure>



<p>接下来，驱动程序运行C编译器(cc1)，它将main.i翻译成一个<strong>ASCI 汇编语言文件</strong>main.s.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cc1 /tmp/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.i</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -<span class="hljs-number">02</span> <span class="hljs-selector-attr">[other arguments]</span> -o /tmp/<span class="hljs-selector-tag">main</span>.s<br></code></pre></td></tr></table></figure>



<p>然后，驱动程序运行汇编器(as)，它将main.s翻译成一个**可重定位目标文件(relocatable object file)**main.o .</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">as <span class="hljs-selector-attr">[other arguments]</span> -o /tmp/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> /tmp/<span class="hljs-selector-tag">main</span>.s<br></code></pre></td></tr></table></figure>



<p>驱动程序经过相同的过程生成swap.0。最后，它运行链接器程序1d，将main.o和swap.o以及一些必要的系统目标文件组合起来，创建一个**可执行目标文件(executable object file)**p .</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld -o <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[system object files and args]</span>/tmp/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> /tmp/swap.o<br></code></pre></td></tr></table></figure>



<p>要运行可执行文件户，我们在命令行上输人它的名字:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./p<br></code></pre></td></tr></table></figure>



<p>外壳调用操作系统中一个叫做<strong>加载器的函数，它拷贝可执行文件p中的代码和数据到存储器</strong>，然后将控制转移到这个程序的开头，</p>
<h1 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2.静态链接"></a>2.静态链接</h1><p>​	<strong>静态链接器(Static Linker)<strong>将</strong>可重定位目标文件</strong>和<strong>命令行参数</strong>作为输入，生成完全链接的可执行目标文件。<strong>可重定位目标文件</strong>由各种代码和数据组成，指令、初始化的全局变量和未初始化的变量分别处于不同部分。</p>
<p>链接器需要完成两个主要任务：</p>
<ul>
<li><strong>符号解析（Symbol Resolution）</strong>：目标文件定义并引用符号，每个符号对应一个函数、全局变量或静态变量（即使用<code>static</code>声明的任何变量）。符号解析的目的是将每个符号引用与一个符号定义相关联；</li>
<li><strong>重定位（Relocation）</strong>：编译器和汇编器生成的代码和数据段是从地址 0 开始的，链接器会重定位所有的符号定义并修改其对应的符号引用。</li>
</ul>
<p>注意：<strong>目标文件只是字节块的集合</strong>，其中可能包含代码、数据或指导链接器和加载器的数据结构。链接器将各个块连接在一起，确定整个块的运行时位置，并修改代码和数据块中的不同位置。编译器和汇编器在生成目标文件时已经完成了大部分工作，因而链接器对目标机器的了解甚少。</p>
<h1 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h1><p>目标文件（Object File）有三种形式：</p>
<ul>
<li><strong>可重定位目标文件</strong>：包含二进制代码和数据，可以在编译时与其他可重定位目标文件组合以创建可执行目标文件；</li>
<li><strong>可执行目标文件</strong>：包含二进制代码和数据形式，可直接被复制到内存中执行；</li>
<li><strong>共享目标文件</strong>：一种<strong>特殊类型的可重定位目标文件</strong>，可以在加载时或运行时被加载到内存中并动态链接。</li>
</ul>
<h1 id="4-可重定位目标文件"><a href="#4-可重定位目标文件" class="headerlink" title="4.可重定位目标文件"></a>4.可重定位目标文件</h1><p>​	典型的 ELF（Executable and Linkable Format）可重定位目标文件格式如下图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/494e335da73a3b07ea5e1507763be10b.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>ELF 头（ELF Header）</strong>：开头是一个<strong>表征系统字长（Word Size）</strong>和<strong>字节顺序（Byte Ordering）</strong>的 16 字节序列。其余部分包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或共享）、机器类型（如 x86-64）、<strong>节头表（Section Header Table）</strong>的文件偏移量以及其中**条目(entry)**的大小和数量；</p>
</li>
<li><p>节头表：描述了目标文件中每个 Section 的位置和大小；</p>
</li>
<li><p>Section：位于 ELF 头和节头表之间，包括：</p>
<ul>
<li>.text：编译后程序的机器码；</li>
<li>.rodata：只读数据，例如<code>printf</code>中的格式字符串，Switch 语句的跳转表等；</li>
<li>.data：<strong>已初始化的全局变量和静态变量</strong>。非静态局部变量在运行时位于栈中，不会出现在 .data 或 .bss 中；</li>
<li>.bss：<strong>未初始化的静态变量，以及初始化为 0 的全局变量和静态变量</strong>。<strong>此 Section 只是一个占位符，在目标文件中不占用实际空间</strong>，因此可以提升空间效率。这些变量在运行时被分配到内存中，初始值为零；</li>
<li>.symtab ：一个保存了在<strong>程序中被定义和引用的函数和全局变量信息</strong>的符号表（Symbol Table）。与编译器中的符号表不同，.symtab 中的符号表不包含任何局部变量；</li>
<li>.rel.text：当链接器将目标文件与其他文件组合时，.text 中的许多位置都需要被修改，而 .rel.text 中则保存了与之相关的重定位信息。通常，任何调用外部函数或引用全局变量的指令都需要被修改，而调用局部函数的指令则不变。可执行目标文件一般不需要重定位信息，因此这部分可以省略；</li>
<li>.rel.data：被引用或定义的任何全局变量的重定位信息。通常，所有初始值为全局变量地址或外部定义函数地址的已初始化全局变量都需要被修改；</li>
<li>.debug：调试符号表，仅在使用<code>-g</code>选项调用编译器驱动时出现；</li>
<li>.line：原始程序中行号与 .text 中机器代码指令之间的映射关系，仅在使用<code>-g</code>选项调用编译器驱动时出现；</li>
<li>.strtab：一个以<code>NULL</code>结尾，包含 .symtab 和 .debug 中的符号表以及 Section 名称的字符串序列。</li>
</ul>
</li>
</ul>
<h1 id="5-符号和符号表"><a href="#5-符号和符号表" class="headerlink" title="5.符号和符号表"></a>5.符号和符号表</h1><p>​	每个目标文件都有一个符号表，其中包含了该文件所定义和引用的符号信息。符号有以下三种：</p>
<ul>
<li><strong>全局符号（Global Symbols）</strong>：由该文件定义并且可以被其他文件引用的符号；</li>
<li><strong>外部符号（Externals）</strong>：被该文件引用但由其他文件定义的符号；</li>
<li><strong>局部符号（Local Symbols）</strong>：由该文件定义且无法被其他文件引用的符号，即使用<code>static</code>声明的函数和变量。</li>
</ul>
<p>​	注意：非静态局部变量在运行时位于栈中，与链接器无关。而静态局部变量则保存在 .data 或 .bss 中，编译器会在符号表中为其创建名称唯一的局部符号。例如同一文件中的两个函数都定义了静态局部变量<code>x</code>：</p>
<div class="note note-secondary">
            <p><strong>给C语言初学者建议:利用 static 属性隐藏变量和函数名字</strong></p><p>C程序员使用 static属性在模块内部隐藏变量和函数声明，就像你在Java和C++中使用public 和 private 声明一样。C源代码文件扮演模块的角色。任何声明带有 static属性的全局变量或者函数都是模块私有的。类似地，任何声明为不带static属性的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static属性来保护你的变量和函数是很好的编程习惯。</p>
          </div>



<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">f</span>()</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">g</span>()</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	那么编译器可能将<code>x.1</code>作为函数<code>f()</code>中的变量符号，将<code>x.2</code>作为函数<code>g()</code>中的变量符号发送给汇编器。<strong>汇编器使用接收到的<code>.s</code>文件中的符号构建符号表</strong>，其中每个条目的数据结构为：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/cd1122519cf50a75b23b03a187d9abf8.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>name</code>：符号名在字符串表 .strtab 中的偏移量；</li>
<li><code>value</code>：对于可重定位目标文件是符号在其 Section 中的偏移量，对于可执行目标文件是符号的运行时地址；</li>
<li><code>size</code>：符号的大小；</li>
<li><code>type</code>：符号的类型；</li>
<li><code>binding</code>：符号是局部的还是全局的；</li>
<li><code>section</code>：符号所在的 Section 在节头表中的索引。</li>
</ul>
<p>值得一提的是，有三个伪 Section 在节头表中没有条目：</p>
<ul>
<li>ABS：不应重定位的符号；</li>
<li>UNDEF：在此文件中引用但在其他文件中定义的符号；</li>
<li>COMMON：未初始化的全局符号</li>
</ul>
<p>上述三个 Section 仅存在于可重定位目标文件，在可执行目标文件中并不存在。我们可以使用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/readelf.1.html">READELF</a> 工具阅读目标文件中的内容，<a href="#1.%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">main.c</a> 生成的目标文件符号表条目如下：</p>
<p>![619376e7c3e3ec1d76562438dc21c413](C:\Users\Administrator\Documents\Tencent Files\3454523412\nt_qq\nt_data\Pic\2024-08\Ori\619376e7c3e3ec1d76562438dc21c413.png)</p>
<p>​	READELF 通过整数索引 Ndx 标识每个 Section，1 表示 .text，3 表示 .data。全局符号<code>main</code>和<code>array</code>分别位于上述两个 Section 首部，因此其偏移量<code>value</code>均为 0。外部符号<code>sum</code>未在本文件中定义，位于 UNDEF。</p>
<p>​	在这个例子中，我们看到一个关于全局符号buf定义的条目，它是一个位于.data节中偏移为零(即value)处的8字节目标。其后跟随着的是全局符号main的定义，它是个位于.text节中偏移为零处的17字节函数。最后一个条目来自对外部符号swap的引用READELF用一个整数索引来标识每个节。Ndx&#x3D;1表示.text节，而Ndx&#x3D;3表示.data节。</p>
<h1 id="6-符号解析"><a href="#6-符号解析" class="headerlink" title="6.符号解析"></a>6.符号解析</h1><p>​	链接器将每个符号引用与符号表中的符号定义相关联以完成<strong>符号解析（Symbol Resolution）</strong>。当编译器遇到未在当前文件中定义的符号时，它会假设该符号已在其他文件中定义，然后生成对应的符号表条目。如果链接器无法在任何输入文件中找到该符号的定义，那么它就会终止链接。</p>
<p>不同文件可能定义了相同名称的全局符号。对于这种情况，链接器要么直接报错，要么选取其中之一。</p>
<div class="note note-secondary">
            <p><strong>对 C++和 Java 中链接器符号的毁坏(mangling)</strong><br>    C++和Java都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢?C++和Java 中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做**毁坏(mangling)<strong>，而相反的过程叫做</strong>恢复(demangling)**。</p><p>​	C++ 和 Java ，使用<strong>兼容</strong>的毁坏策略。允许重载名称相同但参数列表不同的方法。编译器会将每个方法和参数列表组合为一个唯一的名称，这样链接器就可以区分它们。例如，<code>Foo::bar(int, long)</code>会被编码为<code>bar__3Fooil</code>。其中，3 代表类名 Foo 的字符数，i 和 l 则分别代表参数列表中的<code>int</code>和<code>long</code>。</p>
          </div>



<h2 id="6-1-解析名称重复的符号"><a href="#6-1-解析名称重复的符号" class="headerlink" title="6.1 解析名称重复的符号"></a>6.1 解析名称重复的符号</h2><p>​	Linux 编译系统会在编译时将全局符号分为两种类型：函数和已初始化的全局变量是<strong>强符号（strong）</strong>，未初始化的全局变量是<strong>弱符号（weak）</strong>。汇编器将符号的强弱信息隐式地编码到目标文件的符号表中。</p>
<p>链接器解析名称重复的符号的规则为：</p>
<ul>
<li>不允许多个强符号名称重复；</li>
<li>若一个强符号和多个弱符号名称重复，选择强符号；</li>
<li>若多个弱符号名称重复，从中任选其一。</li>
</ul>
<div class="note note-secondary">
            <p>注意：最新版本的 GCC（如 GCC 10）默认使用标识位<code>-fno-common</code>，因此若程序包含多个名称重复的弱符号将引发链接错误</p>
          </div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* foo3.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">15213</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br>    f();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* bar3.c */</span><br><span class="hljs-built_in">int</span> x;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span><br>&#123;<br>    x = <span class="hljs-number">15212</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	示例程序中，文件<code>bar3.c</code>中的函数<code>f</code>是强符号，文件<code>foo3.c</code>中的函数<code>f</code>是弱符号，因此主函数的输出<code>x</code>的值为 15212。</p>
<p>​	上文提到，未初始化的全局变量保存在 COMMON 中，而未初始化的静态变量，以及初始化为 0 的全局变量和静态变量保存在 .bss 中。这是因为前者是弱符号，编译器无法知晓其他文件中是否定义了相同名称的变量，必须将其分配到 COMMON 中并随后由链接器处理。已初始化为 0 的全局变量是强符号，根据第二条解析规则，该变量一定是唯一的，因此编译器可以安心地把它放到 .bss 中。静态变量无法被其他文件引用，自然也无需担心名称重复的问题。</p>
<h2 id="6-2-与静态库相链接"><a href="#6-2-与静态库相链接" class="headerlink" title="6.2 与静态库相链接"></a>6.2 与静态库相链接</h2><p>​	<strong>编译系统将一些相关的目标模块打包到一个文件中，该文件被称为<em>静态库（Static Library</em>）</strong>。在构建可执行目标文件时，链接器<strong>仅复制</strong>静态库中被应用程序引用的<strong>目标模块</strong>，从而减小了磁盘和内存中可执行文件的大小。静态库为我们提供了 I&#x2F;O、字符串操作和数学运算等标准函数。</p>
<p>​	在 Linux 系统中，静态库以特定的文件格式（后缀为<code>.a</code>）存储在磁盘上。应用程序可以在命令行中指定文件名来使用静态库中定义的任何函数（实际上，C 编译器驱动总是将<code>libc.a</code>传递给链接器），如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">linux&gt; gcc main.c /usr/lib/libm.a /usr/lib/libc.a<br></code></pre></td></tr></table></figure>



<p>​	在Unix系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。为了使我们对库的讨论更加形象具体，假设我们想在一个叫做 1ibvector.a的静态库中提供下图中的向量例程。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/7fc9b0388a3eb5f45da37c592fd4f439.png" srcset="/img/loading.gif" lazyload></p>
<p>我们使用 AR 命令将下列程序打包为静态库文件<code>libvector.a</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">linux&gt; gcc -c addvec<span class="hljs-selector-class">.c</span> multvec<span class="hljs-selector-class">.c</span><br>linux&gt; ar rcs libvector<span class="hljs-selector-class">.a</span> addvec<span class="hljs-selector-class">.o</span> multvec.o<br></code></pre></td></tr></table></figure>

<p>接下来再编写一个程序<code>main2.c</code>调用该静态库，头文件<code>vector.h</code>定义了库文件中的函数原型：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/5fa82c697df7838df12800b6d2b7ba3e.png" srcset="/img/loading.gif" lazyload></p>
<p>最后使用如下命令编译并链接main2.o和libvector.a：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">linux&gt; gcc -c main2.c<br>linux&gt; gcc -<span class="hljs-type">static</span> -o p2 main2.o ./libvector.a<br></code></pre></td></tr></table></figure>

<p><strong><code>-static</code>参数表示链接器应当构建一个完全链接的可执行目标文件</strong>，该文件可以被加载到内存中运行而无需进一步地链接。完整的链接流程如下图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/baa40568b0803a179e778c83047e5c7d.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6-3-静态库的符号解析"><a href="#6-3-静态库的符号解析" class="headerlink" title="6.3 静态库的符号解析"></a>6.3 静态库的符号解析</h2><p>​	符号解析时，链接器会按照从左到右的顺序依次扫描命令行中的目标文件和静态库。在这个过程中，E 为可重定位目标文件的集合，U 为被引用但还未找到定义的符号，D 为已扫描过的文件定义的符号，开始时三者均为空。</p>
<ul>
<li>若命令行中的输入文件为可重定位目标文件，则链接器将其添加到 E 中并更新 U 和 D 中的符号；</li>
<li>若命令行中的输入文件为静态库，则链接器会将 U 中的符号与该静态库中定义的符号相匹配。匹配成功的模块会被添加到 E 中，随后链接器更新 U 和 D 中的符号。当 U 和 D 中的符号不再改变时，匹配结束，任何不在 E 中的静态库模块都将被直接丢弃；</li>
<li>若扫描全部完成时 U 为空，则链接器合并并重定位 E 中所有的目标文件以构建可执行文件。否则，链接器将报错并终止。</li>
</ul>
<p>链接器的这种行为限制了命令行中的文件顺序。如果定义符号的静态库出现在引用该符号的目标文件之前，链接就会失败。</p>
<h1 id="7-重定位"><a href="#7-重定位" class="headerlink" title="7.重定位"></a>7.重定位</h1><p>符号解析完成后，链接器会将代码中的每个符号引用与一个符号定义相关联。接下来，链接器开始对目标文件重定位：</p>
<ul>
<li>重定位 Section 和符号定义：链接器将所有输入模块中相同类型的 Section 合并为一个新的聚合 Section，然后将运行时地址分配给每个 Section 和符号；</li>
<li>在 Section 内重定位符号引用：链接器修改代码和数据段中的每个符号引用，使其指向正确的运行时地址。为了执行这一步，它依赖于<strong>重定位条目（Relocation Entry）</strong>这种数据结构。</li>
</ul>
<h2 id="7-1重定位条目"><a href="#7-1重定位条目" class="headerlink" title="7.1重定位条目"></a>7.1重定位条目</h2><p>​	汇编器在生成目标文件时，并不知晓代码、数据和引用的外部符号在内存中的最终位置。它只会为每个引用生成一个重定位条目（Relocation Entry），指导链接器如何修改它们。上文提到，代码的重定位条目放在 .rel.text 中，数据的重定位条目则放在 .rel.data 中。</p>
<p>ELF 重定位条目的数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> offset;    <span class="hljs-comment">/* Offset of the reference to relocate */</span><br>    <span class="hljs-type">long</span> type:<span class="hljs-number">32</span>,   <span class="hljs-comment">/* Relocation type */</span><br>         symbol:<span class="hljs-number">32</span>; <span class="hljs-comment">/* Symbol table index */</span><br>    <span class="hljs-type">long</span> addend;    <span class="hljs-comment">/* Constant part of relocation expression */</span><br>&#125; Elf64_Rela;<br></code></pre></td></tr></table></figure>

<p><code>offset</code>是被修改的引用在其 Section 中的偏移量；<code>symbol</code>是引用指向的符号在符号表中的索引；<code>type</code>告知链接器如何修改引用；<code>addend</code>是一个有符号常量，某些类型的重定位使用它来偏置被修改的引用值。</p>
<p>最基本的两种重定位类型为：</p>
<ul>
<li>R_X86_64_PC32：使用 32 位 PC 相对地址重定位引用。当 CPU 执行一条使用 PC 相对地址的指令时，它会将指令中的目标地址与 PC 当前值（即下一条指令在内存中的地址）相加得到有效地址（在 <a target="_blank" rel="noopener" href="https://koktlzz.github.io/posts/machine-level-representation-of-programs-note/#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4">跳转指令</a> 一节中我们讨论过这一问题）；</li>
<li>R_X86_64_32：使用 32 位绝对地址重定位引用。CPU 直接使用指令中的目标地址作为有效地址，无需进一步地修改。</li>
</ul>
<h2 id="7-2-重定位符号引用"><a href="#7-2-重定位符号引用" class="headerlink" title="7.2 重定位符号引用"></a>7.2 重定位符号引用</h2><p>链接器的重定位算法的伪代码如图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/d447b5578bb67aa0b5fe84c54ea52858.png" srcset="/img/loading.gif" lazyload></p>
<p>​	</p>
<p>​	链接器遍历每个 Section（<code>s</code>）中的每个重定位条目（<code>r</code>）。为了使描述具体化，假设每个节(Section)s是一个字节数组，每个重定位条目r是一个类型为Elf32_Rela的结构体。另外，还设当算法运行时，链接器已经为每个节(用ADDR(S)表示)和每个符号都选择了运行时地址(用ADDR(r.symbol)表示)。第3行计算的是需要被重定位的4字节引用的数组s中的地址（<code>*refptr</code>是指令中的目标地址）。如果这个引用使用的是PC相对寻址，那么它就用第5<del>9行来重定位。如果该引用使用的是绝对寻址，它就通过第 11</del> 13 行来重定位。</p>
<p>我们使用命令<code>objdump -dx main.o</code>得到汇编器为 <a href="#1.%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">main.c</a> 生成的机器码和重定位条目：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/64d46db6560dbda755c64d50acaea0d1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="7-2-1-PC相对地址重定位"><a href="#7-2-1-PC相对地址重定位" class="headerlink" title="7.2.1 PC相对地址重定位"></a>7.2.1 PC相对地址重定位</h3><p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/004701c6a73489a46cb86d6e2e9b5982.png" srcset="/img/loading.gif" lazyload></p>
<p>​	从这个列表中，我们看到ca11指令开始于节偏移0x6处，由1个字节的操作码0xe8和随后的 32位引用0xfffffffc(十进制-4)组成，它是以小端法字节顺序存储的。我们还看到下一行显示的是这个引用的重定位条目。(回想一下，重定位条目和指令实际上是存放在目标文件的不同节中的。OBJDUMP工具为了方便将它们显示在一起。)重定位条目r由3个字段组成:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">r.offset</span> = <span class="hljs-number">0</span>x7<br><span class="hljs-attr">r.symbol</span> = swap<br><span class="hljs-attr">r.type</span>   = R_X<span class="hljs-number">86_64_</span>PC32<br><span class="hljs-attr">r.addend</span> = -<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>​	</p>
<p>​	这些字段告诉链接器修改开始于偏移量0x7.处的32位PC相对引用，使得在运行时它指向swap()。现在，假设链接器已经确定:  ADDR(s)&#x3D;ADDR(.text)&#x3D;0x80483b4  和   ADDR(r.symbol)&#x3D;ADDR(swap)&#x3D;0x80483c8。那么首先我们可以计算得到该引用的运行时地址为：（第七行）</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">refaddr = ADDR(s)  + r<span class="hljs-number">.</span>offset<br>		= <span class="hljs-number">0x80483b4</span> + <span class="hljs-number">0x7</span><br>        = <span class="hljs-number">0x80483bb</span><br></code></pre></td></tr></table></figure>

<p>然后，它将引用从当前值(-4)修改为0x9，使得它在运行时指向swap()(第8行):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">*refptr = (<span class="hljs-name">unsigned</span>) (<span class="hljs-name">ADDR</span>(<span class="hljs-name">r</span>.symbol) + r.addend - refaddr)<br>        = (<span class="hljs-name">unsigned</span>) (<span class="hljs-number">0</span>x80483c8       + (<span class="hljs-name">-4</span>)     - <span class="hljs-number">0</span>x80483bb)<br>        = (<span class="hljs-name">unsigned</span>) (<span class="hljs-number">0</span>x9)<br></code></pre></td></tr></table></figure>

<p>在得到的可执行目标文件中，ca11指令有如下的重定位的形式:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">80483ba</span>:  e8 <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>         ca11  <span class="hljs-number">80483</span>c8 &lt;swap&gt;		swap();<br></code></pre></td></tr></table></figure>

<p>在运行时，ca11指令将存放在地址0x80483ba处。当CPU执行ca11指令时，PC的值为0x80483bf，即紧随在ca11指令之后的指令的地址。为了执行这条指令，CPU执行以下的步骤:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.push PC onto stack<br><span class="hljs-attribute">2</span>.PC&lt;-PC+<span class="hljs-number">0</span>x9=<span class="hljs-number">0</span>x80483bf+<span class="hljs-number">0</span>x9=<span class="hljs-number">0</span>x80483c8<br></code></pre></td></tr></table></figure>

<p>因此，要执行的下一条指令就是 swap 程序的第一条指令.</p>
<div class="note note-secondary">
            <p>你可能想知道为什么汇编器会将ca11指令中的引用的初始值设置为-4。汇编器用这个值作为偏移量，是因为PC总是指向当前指令的<strong>下一条指令</strong>。在有不同指令大小和编码方式的不同的机器上，该机器的汇编器会使用不同的偏移量。这是一个很有用的技巧，它允许链接器透明地重定位引用，很幸运地不用知道某一台机器的指令编码。</p>
          </div>



<h3 id="7-2-2-重定位绝对引用"><a href="#7-2-2-重定位绝对引用" class="headerlink" title="7.2.2 重定位绝对引用"></a>7.2.2 重定位绝对引用</h3><p>回想图7-1中我们的示例程序，swap.o模块将全局指针bufp0初始化为指向全局数组buf的第一个元素的地址:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int *bufpO <span class="hljs-punctuation">=</span><span class="hljs-meta">&amp;buf[0];</span><br></code></pre></td></tr></table></figure>

<p>该引用的重定位条目是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">r.offset = <span class="hljs-number">0x0</span><br>r.symbol = buf<br>r.type   = R_X86_64_32<br>r.addend = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>因为bufp0是一个已初始化的数据目标，那么它将被存放在可重定位目标模块swap.o的.data节中。因为它被初始化为一个全局数组的地址，所以它需要被重定位。下面是 swap.o中。data节的反汇编列表:</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/fe0d062a26dbdf47994c1694f99f3d34.png" srcset="/img/loading.gif" lazyload></p>
<p>我们看到.data节包含一个32位引用，bufp0指针的值为0x0。重定位条目告诉链接器这是一个 32位绝对引用，开始于偏移0处，必须重定位使得它指向符号buf。现在，假设链接器已经确定:</p>
<p>ADDR(r.symbol)&#x3D;ADDR(buf)&#x3D;0x8049454，那么首先我们可以计算得到该引用的运行时地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*refptr = (<span class="hljs-type">unsigned</span>) (ADDR(r.symbol) + *refptr)<br>        = (<span class="hljs-type">unsigned</span>) (<span class="hljs-number">0x8049454</span>      + <span class="hljs-number">0</span>)<br>        = (<span class="hljs-type">unsigned</span>) (<span class="hljs-number">0x8049454</span>)<br></code></pre></td></tr></table></figure>

<p>在得到的可执行目标文件中，引用有下面的重定位形式:</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/5f970249487f23287b62ef56bdb8ad2e.png" srcset="/img/loading.gif" lazyload></p>
<p>总而言之，链接器决定在运行时变量bufp0将放置在存储器地址0x804945c处，并且被初始化为0x8049454，这个值就是buf数组的运行时地址。</p>
<h1 id="8-可执行目标文件"><a href="#8-可执行目标文件" class="headerlink" title="8.可执行目标文件"></a>8.可执行目标文件</h1><p>ELF 可执行目标文件的结构如下：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/839cb440a8e32a0044485b652368eff6.png" srcset="/img/loading.gif" lazyload></p>
<p>​	ELF 头描述了文件的整体格式，并包含了程序在运行时执行的第一条指令的地址。.init 定义了一个名为<code>_init</code>的函数，它将被程序的初始化代码所调用。其余 Section 与可重定位目标文件类似，只不过它们已被重定位到运行时的内存地址。正因如此，该文件中没有 .rel.text 和 .rel.data。</p>
<p>​	ELF可执行文件被设计得很容易加载到存储器，可执行文件的**连续的片(chunk)<strong>被映射到连续的存储器段。</strong>段头部表(segment header table)**描述了这种映射关系。下图 展示了可执行文件 p的段头部表，是由OBJDUMP 显示的。</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/bc91362eb5f5fde40acfa2e586f8f7c6.png" srcset="/img/loading.gif" lazyload></p>
<p>​	从段头部表中，我们会看到根据可执行目标文件的内容初始化两个存储器段。</p>
<p>​	第一个段(代码段)对齐到一个4KB(2”)的边界，有读&#x2F;执行许可，开始于存储器地址 0x08048000处，总共的存储器大小是0x448字节，并且被初始化为可执行目标文件的头0x448 个字节，其中包括ELF头部、段头部表以及.init、.text和.rodata节。<br>​	第二个段(数据段)被对齐到一个4KB的边界，有读&#x2F;写许可开始于存储器地址 0x08049448处，总的存储器大小为0x104字节，并用从文件偏移 0x448处开始的 0xe8个字节初始化，在这种情况下，偏移0x448处正是.data节的开始。该段中剩下的字节对应于运行时将被初始化为零的.bss数据。</p>
<p>对于每个内存段，链接器必须选择一个起始地址 vaddr，使得：</p>
<p>​			<em>vaddr</em> <em>mod</em> <em>align</em>&#x3D; <em>off</em> <em>mod</em> <em>align</em></p>
<p>其中，off 是该内存段中第一个 Section 在目标文件中的偏移量，align 是程序头表中指定的对齐方式。这种对齐要求是一种优化，它可以使目标文件被更加有效地加载到内存中。</p>
<h1 id="9-加载可执行目标"><a href="#9-加载可执行目标" class="headerlink" title="9.加载可执行目标"></a>9.加载可执行目标</h1><p>下图展示了 Linux 程序的运行时内存结构：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/f5b0f8944ad577db9c0399d5a96b7a27.png" srcset="/img/loading.gif" lazyload></p>
<p>​	加载器首先根据程序头表将可执行目标文件中的块复制到内存中的代码和数据段，然后跳转到<strong>程序入口</strong>，即<code>_start_</code>函数（在系统目标文件<code>crt1.o</code>中定义）的地址。该函数再调用<code>libc.so</code>中定义的系统启动函数<code>__libc_start_main</code>，由它初始化执行环境，之后在从.text和.init节中调用了初始化例程后，启动代码调用atexit例程，这个程序附加了一系列在应用程序正常中止时应该调用的程序。exit函数运行atexit注册的函数，然后通过调用_exit将控制返回给操作系统。接着，启动代码调用应用程序的 main 程序，它会开始执行我们的C代码。在应用程序返回之后，启动代码调用exit 程序，它将控制返回给操作系统调用用户级的主函数并处理其返回。</p>
<div class="note note-secondary">
            <p>​					加载器实际上是如何工作的?<br>​	我们对于加载的描述从概念上来说是准确的，但也不完全准确。为了理解加载实际上是如何工作的，你必须理解进程、虚拟存储器和存储器映射的概念，这些我们还没有加以讨论。在后面的第8 章和第9章中遇到这些概念时，我们将重新回到加载的问题上，并逐渐向你揭开它的神秘面纱。<br>​	对于不够有耐心的读者，下面是关于加载实际上是如何工作的一个概述:Unix 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当外壳运行一个程序时，父外壳进程生成一个子进程，它是父进程的一个复制品。子进程通过 execve 系统调用启动加载器。加载器删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk)，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到存储器的数据拷贝。直到 CPU引用一个被映射的虚拟页才会进行拷贝，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到存储器。</p>
          </div>



<h1 id="10-动态链接共享库"><a href="#10-动态链接共享库" class="headerlink" title="10.动态链接共享库"></a>10.动态链接共享库</h1><p>​	静态库会被定期维护和更新，因此程序员需要知晓其变动并将重新链接程序。此外，几乎所有 C 程序都会使用一些标准 I&#x2F;O 函数，例如<code>printf</code>。这些函数的代码将在运行时被复制到每个进程的代码段中，从而导致严重的内存浪费。</p>
<p>​	<strong>共享库（Shared Libraries）</strong>可以解决上述静态库的缺点。它是一种可以在<strong>加载时或运行时于任意内存地址加载并与程序链接的目标模块</strong>，该过程被称为<strong>动态链接（Dynamic Linking）</strong>。共享库在 Linux 系统中以<code>.so</code>为后缀，而在 Windows 系统中则被称为 DLL（Dynamic Linking Libraries）。</p>
<p>​	在任意文件系统中，每个共享库都只有一个<code>.so</code>文件。与静态库不同的是，该文件中的代码和数据可以被引用该库的所有可执行文件共享，而不需要复制到可执行文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* $begin main2 */</span><br><span class="hljs-comment">/* main2.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">addvec</span>(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="hljs-number">0</span>], z[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* $end main2 */</span><br></code></pre></td></tr></table></figure>

<p> 动态链接过程如下图所示：</p>
<p> <img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/5b972378b0fdee43bd8cda4aa7b126b2.png" srcset="/img/loading.gif" lazyload></p>
<p>我们使用如下指令将 addvec.c 和 multvec.c 构建为共享库文件<code>libvector.so</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">linux&gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c<br></code></pre></td></tr></table></figure>

<p>其中，<code>-fpic</code>指示编译器生成 <strong>与位置无关代码（Position-Independent Code</strong>），而<code>-shared</code>则指示链接器创建共享目标文件。一旦共享库文件创建成功，就可以将其链接到示例程序中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">inux&gt; gcc -o prog2l main2.c ./libvector.so<br></code></pre></td></tr></table></figure>

<p>我们需要明确的是，<code>libvector.so</code>的任意代码和数据都没有被复制到可执行文件<code>prog2l</code>中。链接器只会复制一些重定位和符号表信息，它们将在加载时用于解析引用了共享库的符号。</p>
<p>加载器随后读取可执行文件中包含的动态链接器路径，加载并运行它。动态链接器也是一个共享库文件，如 Linux 系统的<code>ld-linux.so</code>。它通过执行以下重定位操作来完成链接：</p>
<ul>
<li>将<code>libc.so</code>的代码和数据重定位到某个内存段；</li>
<li>将<code>libvector.so</code>中的代码和数据重定位到另一个内存段；</li>
<li>将<code>prog2l</code>中所有引用了共享库的符号重定位。</li>
</ul>
<p>最终，动态链接器将控制权转移给应用程序，共享库的位置不会在程序执行期间改变。</p>
<h1 id="11-从应用程序中加载和链接共享库"><a href="#11-从应用程序中加载和链接共享库" class="headerlink" title="11.从应用程序中加载和链接共享库"></a>11.从应用程序中加载和链接共享库</h1><p>​	应用程序还可以在运行时请求动态链接器加载和链接共享库，其应用场景包括：Windows 应用程序的开发人员使用共享库来分发软件更新；现代 Web 服务器使用<strong>动态链接有效地更新或添加功能</strong>。</p>
<p>Linux 系统为应用程序提供了一些简单接口以实现上述功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">// Returns: pointer to handle if OK, NULL on error</span><br></code></pre></td></tr></table></figure>

<p>函数<code>dlopen</code>加载并链接共享库文件<code>filename</code>，参数<code>flag</code>可以是<code>RTLD_GLOBAL</code>、<code>RTLD_NOW</code>和<code>RTLD_LAZY</code>中的一个或多个（详见 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlopen.3.html">dlopen</a>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle, <span class="hljs-type">char</span> *symbol)</span>;<br><span class="hljs-comment">// Returns: pointer to symbol if OK, NULL on error</span><br></code></pre></td></tr></table></figure>

<p>类似的接口函数还有 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlsym.3.html">dlsym</a>、<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlclose.3.html">dlclose</a> 和 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlerror.3.html">dlerror</a>。<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/2e/ics2/code/link/dll.c">示例程序</a> 展示了应用程序是如何调用它们来动态链接共享库的。</p>
<div class="note note-secondary">
            <p>​		共享库和 Java 本地接口</p><p>​	Java定义了一个标准调用规则，叫做Java本地接口(Java Native Interface，JNI)，它允许Java程序调用“本地的”C和C++函数。JNI的基本思想是将本地C函数，如foo，编译到共享库中，如foo.so。当一个正在运行的Java程序试图调用画数fo0时，Java解释程序利用dlopen 接口(或者与其类似的接口)动态链接和加载 foo.so，然后再调用 foo。</p>
          </div>

<h1 id="12-与位置无关代码"><a href="#12-与位置无关代码" class="headerlink" title="12.与位置无关代码"></a>12.与位置无关代码</h1><p>​	现代系统在编译共享库时会生成一种无需重定位即可被加载到内存中任意位置的代码，即与位置无关代码（Position-Independent Code，PIC），这样共享库就能被多个正在运行的进程同时引用。</p>
<h2 id="7-12-1-PIC数据引用"><a href="#7-12-1-PIC数据引用" class="headerlink" title="7.12.1 PIC数据引用"></a>7.12.1 PIC数据引用</h2><p>​	编译器在 PIC 数据段的开头创建了一个全局偏移量表（Global Offset Table，GOT），其中的每个条目都对应一个被目标模块引用的全局符号。编译器还会为这些条目生成重定位记录。加载时，动态链接器重定位每个 GOT 条目，使其包含被引用符号的绝对地址。每个引用了全局符号的目标模块都有自己的 GOT。</p>
<p>下图展示了示例共享库<code>libvector.so</code>中的 GOT：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/20220331211838.png" srcset="/img/loading.gif" lazyload></p>
<p>​	无论我们在何处加载共享模块，其数据段与代码段之间的距离始终相同。因此，代码段中的<code>addl</code>与数据段中的 GOT[3] 之间的偏移量是一个运行时常量。当函数<code>addvec</code>引用全局变量<code>addcnt</code>时，先通过<code>0x2008b9(%rip)</code>计算得到 GOT[3] 的地址，然后从中读取加载时被动态链接器赋予的<code>addcnt</code>的绝对地址。</p>
<h2 id="7-12-2-PIC函数调用"><a href="#7-12-2-PIC函数调用" class="headerlink" title="7.12.2 PIC函数调用"></a>7.12.2 PIC函数调用</h2><p>​	PIC 函数调用的运行时地址是在该函数第一次被调用时确定的，这种技术被称为延迟绑定（Lazy Binding）。当应用程序导入了一个包含成百上千个函数的共享库（如<code>libc.so</code>），却只调用其中一小部分的函数时，这种技术可以大大减少加载时不必要的重定位操作。</p>
<p>​	延迟绑定是通过 GOT 和过程链接表（Procedure Linkage Table，PLT）共同实现的。只要目标模块调用了共享库中定义的函数，那么它就有自己的 GOT 和 PLT。上文提到，GOT 是数据段的一部分，而 PLT 则是代码段的一部分。</p>
<p>GOT 和 PLT 在运行时协同工作解析函数地址的过程如下图所示：</p>
<p><img src="/2024/08/26/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-5-%E4%BC%98%E5%8C%96/20220401173947.png" srcset="/img/loading.gif" lazyload></p>
<p>​	可执行文件中每个对共享库函数的调用都与 PLT 数组中的条目对应。其中，PLT[0] 是跳转到动态链接器的特殊条目，PLT[1] 对应系统启动函数<code>__libc_start_main</code>。从 PLT[2] 开始的条目对应用户代码调用的函数，如图中的<code>addvec</code>。</p>
<p>​	当与 PLT 一起使用时，GOT [0] 和 GOT[1] 包含了动态连接器在解析函数地址时所需的信息，GOT[2] 是动态链接器的入口点。其余的每个条目均对应于一个在运行时需要被解析地址的调用函数，以及一个 PLT 条目。例如，GOT[4] 和 PLT[2] 与<code>addvec</code>对应。</p>
<p>程序第一次调用<code>addvec</code>并解析其地址的过程如上图（a）所示：</p>
<ol>
<li>PLT[2] 是该函数的入口，程序首先调用它；</li>
<li>PLT[2] 中的第一条指令间接跳转到 GOT[4]。由于最初每个 GOT 条目都指向对应 PLT 条目中的第二条指令，因此控制权将转移到 PLT[2] 中的第二条指令；</li>
<li>PLT[2] 中的第二条指令将<code>addvec</code>的 ID 0x1 压入栈中，第三条指令跳转到 PLT[0]；</li>
<li>PLT[0] 中的第一条指令将 *GOT[1] 压入栈中，第二条指令通过 GOT[2] 间接跳转到动态链接器。动态链接器根据被压入栈中的两个条目确定<code>addvec</code>的运行时地址并用它覆盖 GOT[4]，最终将控制权转移给<code>addvec</code>。</li>
</ol>
<p>程序再次调用<code>addvec</code>的过程如上图（b）所示：</p>
<ol>
<li>程序依然首先调用 PLT[2]；</li>
<li>此时 GOT[4] 指向了<code>addvec</code>，因此控制权将被直接转移到该函数。</li>
</ol>
<h1 id="13-库插入"><a href="#13-库插入" class="headerlink" title="13.库插入"></a>13.库插入</h1><p>​	<strong>库插入（Library Interpositioning</strong>）能够拦截程序对共享库函数的调用，并执行用户自定义的代码。基于这项技术，我们可以计算库函数的调用次数，验证并跟踪其输入和输出的值，甚至将其替换为完全不同的函数。</p>
<p>库插入的基本思想是创建一个与库函数原型相同的包装函数，然后“欺骗”系统调用包装函数而非库函数。通常，包装函数会执行自己的逻辑，调用库函数并将其返回值传递给调用者。</p>
<p>库插入可以在编译时、链接时以及运行时使用。</p>
<h1 id="14-处理目标文件的工具"><a href="#14-处理目标文件的工具" class="headerlink" title="14.处理目标文件的工具"></a>14.处理目标文件的工具</h1><p>​	在 Linux 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU bimutils<br>包尤其有帮助，而且可以运行在每个 Linux 平台上。</p>
<ul>
<li>AR:创建静态库，插入、删除、列出和提取成员。</li>
<li>STRINGS:列出一个目标文件中所有可打印的字符串。</li>
<li>STRIP:从目标文件中删除符号表信息。</li>
<li>NM:列出一个目标文件的符号表中定义的符号，</li>
<li>SIZE:列出目标文件中节的名字和大小。</li>
<li>READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE 和</li>
<li>NM 的功能。</li>
<li>OBJDUMP:所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用</li>
<li>是反汇编.text节中的二进制指令。</li>
</ul>
<p>Unix 系统为操作共享库还提供了LDD程序:</p>
<ul>
<li>LDD:列出一个可执行文件在运行时所需要的共享库</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="print-no-link">#阅读笔记</a>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP_阅读笔记_7_链接</div>
      <div>http://example.com/2024/08/28/CSAPP-阅读笔记-7-链接/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>7qing</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月28日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年8月30日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/27/CSAPP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP_阅读笔记_6_存储器层次结构">
                        <span class="hidden-mobile">CSAPP_阅读笔记_6_存储器层次结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"j6Zz0VRaYO9vOd5c4lYcbJ0l-gzGzoHsz","appKey":"IdTuwk7eTRDfLgZzPUknFG0z","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
